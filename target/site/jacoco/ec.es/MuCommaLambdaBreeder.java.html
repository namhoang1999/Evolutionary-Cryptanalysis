<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MuCommaLambdaBreeder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">ecj</a> &gt; <a href="index.source.html" class="el_package">ec.es</a> &gt; <span class="el_source">MuCommaLambdaBreeder.java</span></div><h1>MuCommaLambdaBreeder.java</h1><pre class="source lang-java linenums">/*
  Copyright 2006 by Sean Luke
  Licensed under the Academic Free License version 3.0
  See the file &quot;LICENSE&quot; for more information
*/


package ec.es;
import java.util.ArrayList;

import ec.*;
import ec.util.*;

/* 
 * MuCommaLambdaBreeder.java
 * 
 * Created: Thu Sep  7 17:27:47 2000
 * By: Sean Luke
 */

/**
 * MuCommaLambdaBreeder is a Breeder which, together with
 * ESSelection, implements the (mu,lambda) breeding strategy and gathers
 * the comparison data you can use to implement a 1/5-rule mutation mechanism.
 * 
 * &lt;p&gt;Evolution strategies breeders require a &quot;mu&quot; parameter and a &quot;lambda&quot;
 * parameter for each subpopulation.  &quot;mu&quot; refers to the number of parents
 * from which the new population will be built.  &quot;lambda&quot; refers to the
 * number of children generated by the mu parents.  Subpopulation sizes
 * will change as necessary to accommodate this fact in later generations.
 * The only rule for initial subpopulation sizes is that they must be
 * greater than or equal to the mu parameter for that subpopulation.
 *
 * &lt;p&gt;You can now set your initial subpopulation
 * size to whatever you like, totally independent of lambda and mu,
 * as long as it is &amp;gt;= mu.
 *
 * &lt;p&gt;MuCommaLambdaBreeder stores mu and lambda values for each subpopulation
 * in the population, as well as comparisons.  A comparison tells you
 * if &amp;gt;1/5, &amp;lt;1/5 or =1/5 of the new population was better than its
 * parents (the so-called evolution strategies &quot;one-fifth rule&quot;.
 * Although the comparisons are gathered, no mutation objects are provided
 * which actually &lt;i&gt;use&lt;/i&gt; them -- you're free to use them in any mutation
 * objects you care to devise which requires them.
 *
 * &lt;p&gt;To do evolution strategies evolution, the
 * breeding pipelines should contain at least one ESSelection selection method.
 * While a child is being generated by the pipeline, the ESSelection object will return a parent
 * from the pool of mu parents.  The particular parent is chosen round-robin, so all the parents
 * will have an equal number of children.  It's perfectly fine to have more than one ESSelection
 * object in the tree, or to call the same one repeatedly during the course of generating a child;
 * all such objects will consistently return the same parent.  They only increment to the next
 * parent in the pool of mu parents after the child has been created from the pipeline.  You can
 * also mix ESSelection operators with other operators (like Tournament Selection).  But you ought
 * to have &lt;b&gt;at least one&lt;/b&gt; ESSelection operator in the pipeline -- else it wouldn't be Evolution
 * Strategies, would it?
 
 &lt;p&gt;&lt;b&gt;Parameters&lt;/b&gt;&lt;br&gt;
 &lt;table&gt;
 &lt;tr&gt;&lt;td valign=top&gt;es.lambda.&lt;i&gt;subpop-num&lt;/i&gt;&lt;br&gt;
 &lt;font size=-1&gt;int &gt;= 0&lt;/font&gt;&lt;/td&gt;&lt;td&gt;Specifies the 'lambda' parameter for the subpopulation.&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;&lt;td valign=top&gt;es.mu.&lt;i&gt;subpop-num&lt;/i&gt;&lt;br&gt;
 &lt;font size=-1&gt;int:  a multiple of &quot;lambda&quot;&lt;/font&gt;&lt;/td&gt;&lt;td&gt;Specifies the 'mu' parameter for the subpopulation.&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/table&gt;

 * @author Sean Luke
 * @version 1.0 
 */

<span class="nc" id="L72">public class MuCommaLambdaBreeder extends Breeder</span>
    {    
    private static final long serialVersionUID = 1;
    
    public static final String P_MU = &quot;mu&quot;;
    public static final String P_MU_FRACTION = &quot;mu-fraction&quot;;
    public static final String P_LAMBDA = &quot;lambda&quot;;

    public int[] mu;
    public int[] lambda;
    
    public Population parentPopulation;

    public byte[] comparison; 
    public static final byte C_OVER_ONE_FIFTH_BETTER = 1;
    public static final byte C_UNDER_ONE_FIFTH_BETTER = -1;
    public static final byte C_EXACTLY_ONE_FIFTH_BETTER = 0;
   
    // This is a DOUBLE ARRAY of ARRAYLISTS of &lt;INDIVIDUALS&gt;
    // Individuals are stored here by the breed pop chunk methods, and afterwards
    // we coalesce them into the new population. 
    public ArrayList newIndividuals[/*subpop*/][/*thread*/];
        
    /** Modified by multiple threads, don't fool with this */
    public int[] count;

    /** lambda should be no SMALLER than mu times this value. 
        This varies between (mu,lambda) (where it's 2) and
        (mu + lambda) (where it's 1).
    */
<span class="nc" id="L102">    public int maximumMuLambdaDivisor() { return 2; }</span>

    public void setup(final EvolutionState state, final Parameter base)
        {
        // we're not using the base
<span class="nc" id="L107">        Parameter p = new Parameter(Initializer.P_POP).push(Population.P_SIZE);</span>
<span class="nc" id="L108">        int size = state.parameters.getInt(p,null,1);  // if size is wrong, we'll let Population complain about it -- for us, we'll just make 0-sized arrays and drop out.</span>
        
<span class="nc" id="L110">        mu = new int[size];</span>
<span class="nc" id="L111">        lambda = new int[size];</span>
<span class="nc" id="L112">        comparison = new byte[size];</span>
        
        // load mu and lambda data
<span class="nc bnc" id="L115" title="All 2 branches missed.">        for(int x=0;x&lt;size;x++)</span>
            {
<span class="nc" id="L117">            Parameter pp = new Parameter(Initializer.P_POP).push(Population.P_SUBPOP).push(&quot;&quot;+x).push(Subpopulation.P_SUBPOPSIZE);</span>
<span class="nc" id="L118">            int ppval = state.parameters.getInt(pp, null, 1);</span>
<span class="nc bnc" id="L119" title="All 2 branches missed.">            if (state.parameters.exists(ESDefaults.base().push(P_LAMBDA).push(&quot;&quot;+x),null))  // we have a lambda</span>
                {
<span class="nc" id="L121">                lambda[x] = state.parameters.getInt(ESDefaults.base().push(P_LAMBDA).push(&quot;&quot;+x),null,1);            </span>
<span class="nc bnc" id="L122" title="All 2 branches missed.">                if (lambda[x]==0) state.output.error(&quot;lambda must be an integer &gt;= 1&quot;,ESDefaults.base().push(P_LAMBDA).push(&quot;&quot;+x));</span>
                }
            else
                {
<span class="nc" id="L126">                state.output.warning(&quot;lambda not specified for subpopulation &quot; + x + &quot;, setting it to the subpopulation size, that is, &quot; + ppval + &quot;.&quot;, </span>
<span class="nc" id="L127">                    ESDefaults.base().push(P_LAMBDA).push(&quot;&quot;+x),null);</span>
<span class="nc" id="L128">                lambda[x] = ppval;</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">                if (lambda[x] == 0)</span>
<span class="nc" id="L130">                    state.output.error(&quot;Subpouplation Size must be &gt;= 1&quot;, pp, null);</span>
                }
                                
<span class="nc bnc" id="L133" title="All 2 branches missed.">            if (state.parameters.exists(ESDefaults.base().push(P_MU).push(&quot;&quot;+x),null))  // we defined mu</span>
                {
                // did we also define a mu-fraction?
<span class="nc bnc" id="L136" title="All 2 branches missed.">                if (state.parameters.exists(ESDefaults.base().push(P_MU_FRACTION).push(&quot;&quot;+x), null))</span>
<span class="nc" id="L137">                    state.output.warning(&quot;Defined both a mu and mu-fraction for subpopulation &quot; + x + &quot;.  Only mu will be used. &quot;, </span>
<span class="nc" id="L138">                        ESDefaults.base().push(P_MU).push(&quot;&quot;+x),</span>
<span class="nc" id="L139">                        ESDefaults.base().push(P_MU_FRACTION).push(&quot;&quot;+x));</span>
                
<span class="nc" id="L141">                mu[x] = state.parameters.getInt(ESDefaults.base().push(P_MU).push(&quot;&quot;+x),null,1);       </span>
<span class="nc bnc" id="L142" title="All 2 branches missed.">                if (mu[x]==0) state.output.error(&quot;mu must be an integer &gt;= 1&quot;,ESDefaults.base().push(P_MU).push(&quot;&quot;+x), null);</span>
<span class="nc bnc" id="L143" title="All 2 branches missed.">                else if (lambda[x] % mu[x] != 0)</span>
                    {
<span class="nc bnc" id="L145" title="All 2 branches missed.">                    if (mu[x] &gt; lambda[x] / maximumMuLambdaDivisor())</span>
                        {
<span class="nc" id="L147">                        state.output.warning(&quot;mu (&quot; + mu[x] + &quot;) for subpopulation &quot; + x + &quot; is greater than lambda (&quot; + lambda[x] + &quot;) / &quot; + maximumMuLambdaDivisor() + &quot;.  Mu will be set to half of lambda, that is, &quot; + lambda[x] / maximumMuLambdaDivisor() + &quot;.&quot;);                        </span>
<span class="nc" id="L148">                        mu[x] = lambda[x] / maximumMuLambdaDivisor();</span>
                        }
        
<span class="nc bnc" id="L151" title="All 2 branches missed.">                    if (lambda[x] % mu[x] != 0)  // check again</span>
<span class="nc" id="L152">                        state.output.error(&quot;mu must be a divisor of lambda&quot;, ESDefaults.base().push(P_MU).push(&quot;&quot;+x));</span>
                    }
<span class="nc bnc" id="L154" title="All 2 branches missed.">                else if (mu[x] &gt; ppval)</span>
                    {
<span class="nc" id="L156">                    state.output.warning(&quot;mu is presently &gt; the initial subpopulation size.  Mu will be set to the subpopulation size, that is, &quot; + ppval + &quot;.&quot;, ESDefaults.base().push(P_MU).push(&quot;&quot;+x), null);</span>
<span class="nc" id="L157">                    mu[x] = ppval;</span>
                    }
                }
<span class="nc bnc" id="L160" title="All 2 branches missed.">            else if (state.parameters.exists(ESDefaults.base().push(P_MU_FRACTION).push(&quot;&quot;+x), null))  // we defined mu in terms of a fraction</span>
                {
<span class="nc" id="L162">                double mufrac = state.parameters.getDoubleWithMax(ESDefaults.base().push(P_MU_FRACTION).push(&quot;&quot;+x), null, 0.0, 1.0 / maximumMuLambdaDivisor());</span>
<span class="nc bnc" id="L163" title="All 2 branches missed.">                if (mufrac &lt; 0.0)</span>
<span class="nc" id="L164">                    state.output.fatal(&quot;Mu-Fraction must be a value between 0.0 and &quot; + 1.0 / maximumMuLambdaDivisor(), ESDefaults.base().push(P_MU_FRACTION).push(&quot;&quot;+x), null);</span>
                                
<span class="nc" id="L166">                int m = (int)Math.max(lambda[x] * mufrac, 1.0);</span>
<span class="nc" id="L167">                mu[x] = m;</span>
                // find the largest divisor of lambda[x] which is &lt;= m. This is ugly
<span class="nc" id="L169">                double val = lambda[x] / (double) mu[x];</span>
<span class="nc bnc" id="L170" title="All 2 branches missed.">                while (val != (int) val)</span>
                    {
<span class="nc" id="L172">                    mu[x]--;</span>
<span class="nc" id="L173">                    val = lambda[x] / (double) mu[x];</span>
                    }
<span class="nc" id="L175">                state.output.message(&quot;Mu-Fraction &quot; + mufrac + &quot; yields a mu of &quot; + m + &quot;, adjusted to &quot; + mu[x]);</span>
<span class="nc" id="L176">                }</span>
<span class="nc" id="L177">            else state.output.fatal(&quot;Neither a Mu or a Mu-Fraction was provided for subpopulation &quot; + x, ESDefaults.base().push(P_MU).push(&quot;&quot;+x), ESDefaults.base().push(P_MU_FRACTION).push(&quot;&quot;+x));</span>
            }
<span class="nc" id="L179">        state.output.exitIfErrors();</span>
<span class="nc" id="L180">        }</span>
                

    public Population breedPopulation(EvolutionState state) 
        {
        // Complete 1/5 statistics for last population
        
<span class="nc bnc" id="L187" title="All 2 branches missed.">        if (parentPopulation != null)</span>
            {
            // Only go from 0 to lambda-1, as the remaining individuals may be parents.
            // A child C's parent's index I is equal to C / mu[subpopulation].
<span class="nc bnc" id="L191" title="All 2 branches missed.">            for (int x = 0; x&lt; state.population.subpops.size(); x++)</span>
                {
<span class="nc" id="L193">                int numChildrenBetter = 0;</span>
<span class="nc bnc" id="L194" title="All 2 branches missed.">                for (int i = 0; i &lt; lambda[x]; i++)</span>
                    {
<span class="nc" id="L196">                    int parent = i / (lambda[x] / mu[x]);  // note integer division</span>
<span class="nc bnc" id="L197" title="All 2 branches missed.">                    if (state.population.subpops.get(x).individuals.get(i).fitness.betterThan(parentPopulation.subpops.get(x).individuals.get(parent).fitness))</span>
<span class="nc" id="L198">                        numChildrenBetter++;</span>
                    }
<span class="nc bnc" id="L200" title="All 2 branches missed.">                if (numChildrenBetter &gt; lambda[x] / 5.0)  // note double division</span>
<span class="nc" id="L201">                    comparison[x] = C_OVER_ONE_FIFTH_BETTER;</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">                else if (numChildrenBetter &lt; lambda[x] / 5.0)  // note double division</span>
<span class="nc" id="L203">                    comparison[x] = C_UNDER_ONE_FIFTH_BETTER;</span>
<span class="nc" id="L204">                else comparison[x] = C_EXACTLY_ONE_FIFTH_BETTER;</span>
                }
            }
                        
        // load the parent population
<span class="nc" id="L209">        parentPopulation = state.population;</span>
        
        // MU COMPUTATION
        
        // At this point we need to do load our population info
        // and make sure it jibes with our mu info

        // the first issue is: is the number of subpopulations
        // equal to the number of mu's?

<span class="nc bnc" id="L219" title="All 2 branches missed.">        if (mu.length!= state.population.subpops.size()) // uh oh</span>
<span class="nc" id="L220">            state.output.fatal(&quot;For some reason the number of subpops is different than was specified in the file (conflicting with Mu and Lambda storage).&quot;,null);</span>

        // next, load our population, make sure there are no subpopulations smaller than the mu's
<span class="nc bnc" id="L223" title="All 2 branches missed.">        for(int x = 0; x&lt; state.population.subpops.size(); x++)</span>
            {
<span class="nc bnc" id="L225" title="All 2 branches missed.">            if (state.population.subpops.get(0).individuals.size() &lt; mu[x])</span>
<span class="nc" id="L226">                state.output.error(&quot;Subpopulation &quot; + x + &quot; must be a multiple of the equivalent mu (that is, &quot;+ mu[x]+&quot;).&quot;);</span>
            }
<span class="nc" id="L228">        state.output.exitIfErrors();</span>
        
        
        // sort evaluation to get the Mu best of each subpopulation
        
<span class="nc bnc" id="L233" title="All 2 branches missed.">        for(int x = 0; x&lt; state.population.subpops.size(); x++)</span>
            {
<span class="nc" id="L235">            final ArrayList&lt;Individual&gt; i = state.population.subpops.get(x).individuals;</span>

<span class="nc" id="L237">            java.util.Collections.sort(i,</span>
                new java.util.Comparator&lt;Individual&gt;()
<span class="nc" id="L239">                    {</span>
                    public int compare(Individual i1, Individual i2)
                        {
<span class="nc" id="L242">                        Individual a = i1;</span>
<span class="nc" id="L243">                        Individual b = i2;</span>
                        // return 1 if should appear after object b in the array.
                        // This is the case if a has WORSE fitness.
<span class="nc bnc" id="L246" title="All 2 branches missed.">                        if (b.fitness.betterThan(a.fitness)) return 1;</span>
                        // return -1 if a should appear before object b in the array.
                        // This is the case if b has WORSE fitness.
<span class="nc bnc" id="L249" title="All 2 branches missed.">                        if (a.fitness.betterThan(b.fitness)) return -1;</span>
                        // else return 0
<span class="nc" id="L251">                        return 0;</span>
                        }
                    });
            }

        // now the subpops are sorted so that the best individuals appear in the lowest indexes.

<span class="nc" id="L258">        Population newpop = (Population) state.population.emptyClone();</span>
        
        // create the count array
<span class="nc" id="L261">        count = new int[state.breedthreads];</span>

        // divvy up the lambda individuals to create
        // how many threads do we really need?  No more than the maximum number of individuals in any subpopulation
<span class="nc" id="L265">        int numThreads = 0;</span>
<span class="nc bnc" id="L266" title="All 2 branches missed.">        for(int x = 0; x &lt; state.population.subpops.size(); x++)</span>
<span class="nc" id="L267">            numThreads = Math.max(numThreads, lambda[x]);</span>
<span class="nc" id="L268">        numThreads = Math.min(numThreads, state.breedthreads);</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">        if (numThreads &lt; state.breedthreads)</span>
<span class="nc" id="L270">            state.output.warnOnce(&quot;Largest lambda size (&quot; + numThreads +&quot;) is smaller than number of breedthreads (&quot; + state.breedthreads +</span>
                &quot;), so fewer breedthreads will be created.&quot;);
            
<span class="nc" id="L273">        newIndividuals = new ArrayList[state.population.subpops.size()][numThreads];</span>
<span class="nc bnc" id="L274" title="All 2 branches missed.">        for(int subpop = 0; subpop &lt; state.population.subpops.size(); subpop++)</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">            for(int thread = 0; thread &lt; numThreads; thread++)</span>
<span class="nc" id="L276">                newIndividuals[subpop][thread] = new ArrayList&lt;Individual&gt;();</span>
            
<span class="nc" id="L278">        int numinds[][] = </span>
<span class="nc" id="L279">            new int[numThreads][state.population.subpops.size()];</span>
<span class="nc" id="L280">        int from[][] = </span>
<span class="nc" id="L281">            new int[numThreads][state.population.subpops.size()];</span>
        
<span class="nc bnc" id="L283" title="All 2 branches missed.">        for(int x = 0; x&lt; state.population.subpops.size(); x++)</span>
            {
<span class="nc bnc" id="L285" title="All 2 branches missed.">            for(int thread = 0; thread &lt; numThreads; thread++)</span>
<span class="nc" id="L286">                newIndividuals[x][thread].clear();</span>

<span class="nc" id="L288">            int length = lambda[x];</span>

            // we will have some extra individuals.  We distribute these among the early subpopulations
<span class="nc" id="L291">            int individualsPerThread = length / numThreads;  // integer division</span>
<span class="nc" id="L292">            int slop = length - numThreads * individualsPerThread;</span>
<span class="nc" id="L293">            int currentFrom = 0;</span>
                                
<span class="nc bnc" id="L295" title="All 2 branches missed.">            for(int y=0;y&lt;numThreads;y++)</span>
                {
<span class="nc bnc" id="L297" title="All 2 branches missed.">                if (slop &gt; 0)</span>
                    {
<span class="nc" id="L299">                    numinds[y][x] = individualsPerThread + 1;</span>
<span class="nc" id="L300">                    slop--;</span>
                    }
                else
<span class="nc" id="L303">                    numinds[y][x] = individualsPerThread;</span>
                    
<span class="nc bnc" id="L305" title="All 2 branches missed.">                if (numinds[y][x] == 0)</span>
                    {
<span class="nc" id="L307">                    state.output.warnOnce(&quot;More threads exist than can be used to breed some subpopulations (first example: subpopulation &quot; + x + &quot;)&quot;);</span>
                    }
                    
<span class="nc" id="L310">                from[y][x] = currentFrom;</span>
<span class="nc" id="L311">                currentFrom += numinds[y][x];</span>
                }
            }
                     
<span class="nc bnc" id="L315" title="All 2 branches missed.">        if (numThreads==1)</span>
            {
<span class="nc" id="L317">            breedPopChunk(newpop,state,numinds[0],from[0],0);</span>
            }
        else
            {
<span class="nc" id="L321">            Thread[] t = new Thread[numThreads];</span>
                
            // start up the threads
<span class="nc bnc" id="L324" title="All 2 branches missed.">            for(int y=0;y&lt;numThreads;y++)</span>
                {
<span class="nc" id="L326">                MuLambdaBreederThread r = new MuLambdaBreederThread();</span>
<span class="nc" id="L327">                r.threadnum = y;</span>
<span class="nc" id="L328">                r.newpop = newpop;</span>
<span class="nc" id="L329">                r.numinds = numinds[y];</span>
<span class="nc" id="L330">                r.from = from[y];</span>
<span class="nc" id="L331">                r.me = this;</span>
<span class="nc" id="L332">                r.state = state;</span>
<span class="nc" id="L333">                t[y] = new Thread(r);</span>
<span class="nc" id="L334">                t[y].start();</span>
                }
                
            // gather the threads
<span class="nc bnc" id="L338" title="All 2 branches missed.">            for(int y=0;y&lt;numThreads;y++) </span>
                try
                    {
<span class="nc" id="L341">                    t[y].join();</span>
                    }
<span class="nc" id="L343">                catch(InterruptedException e)</span>
                    {
<span class="nc" id="L345">                    state.output.fatal(&quot;Whoa! The main breeding thread got interrupted!  Dying...&quot;);</span>
<span class="nc" id="L346">                    }</span>
            }
            
        // Coalesce
<span class="nc bnc" id="L350" title="All 2 branches missed.">        for(int subpop = 0; subpop &lt; state.population.subpops.size(); subpop++)</span>
            {
<span class="nc" id="L352">            ArrayList&lt;Individual&gt; newpopindividuals = newpop.subpops.get(subpop).individuals;</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">            for(int thread = 0; thread &lt; numThreads; thread++)</span>
                {
<span class="nc" id="L355">                newpopindividuals.addAll(newIndividuals[subpop][thread]);</span>
                }
            }

<span class="nc" id="L359">        return postProcess(newpop,state.population,state);</span>
        }

    /** A hook for Mu+Lambda, not used in Mu,Lambda */

    public Population postProcess(Population newpop, Population oldpop, EvolutionState state)
        {
<span class="nc" id="L366">        return newpop;</span>
        }
    
    
    int[] children;
    int[] parents;
    
    
    /** A private helper function for breedPopulation which breeds a chunk
        of individuals in a subpopulation for a given thread.
        Although this method is declared
        public (for the benefit of a private helper class in this file),
        you should not call it. */
    
    public void breedPopChunk(Population newpop, EvolutionState state, int[] numinds, int[] from, int threadnum) 
        {
<span class="nc bnc" id="L382" title="All 2 branches missed.">        for(int subpop = 0; subpop&lt; newpop.subpops.size(); subpop++)</span>
            {
<span class="nc" id="L384">            ArrayList&lt;Individual&gt; putHere = (ArrayList&lt;Individual&gt;)newIndividuals[subpop][threadnum];</span>

            // reset the appropriate count slot  -- this used to be outside the for-loop, a bug
            // I believe
<span class="nc" id="L388">            count[threadnum]=0;</span>
        
<span class="nc" id="L390">            BreedingSource bp = (BreedingSource) newpop.subpops.get(subpop).</span>
<span class="nc" id="L391">                species.pipe_prototype.clone();</span>
            
            // check to make sure that the breeding pipeline produces
            // the right kind of individuals.  Don't want a mistake there! :-)
<span class="nc bnc" id="L395" title="All 2 branches missed.">            if (!bp.produces(state,newpop,subpop,threadnum))</span>
<span class="nc" id="L396">                state.output.fatal(&quot;The Breeding Source of subpopulation &quot; + subpop + &quot; does not produce individuals of the expected species &quot; + newpop.subpops.get(subpop).species.getClass().getName() + &quot; or fitness &quot; + newpop.subpops.get(subpop).species.f_prototype );</span>
<span class="nc" id="L397">            bp.prepareToProduce(state,subpop,threadnum);</span>
<span class="nc bnc" id="L398" title="All 2 branches missed.">            if (count[threadnum] == 0)  // the ESSelection didn't set it to nonzero to inform us of his existence</span>
<span class="nc" id="L399">                state.output.warnOnce(&quot;Whoa!  Breeding Source for subpop &quot; + subpop + &quot; doesn't have an ESSelection, but is being used by MuCommaLambdaBreeder or MuPlusLambdaBreeder.  That's probably not right.&quot;);</span>
            // reset again
<span class="nc" id="L401">            count[threadnum] = 0;</span>
        
            // start breedin'!
            
<span class="nc" id="L405">            int upperbound = from[subpop]+numinds[subpop];</span>
<span class="nc bnc" id="L406" title="All 2 branches missed.">            for(int x=from[subpop];x&lt;upperbound;x++)</span>
                {
<span class="nc bnc" id="L408" title="All 2 branches missed.">                if (bp.produce(1,1,subpop, putHere, state,threadnum, newpop.subpops.get(subpop).species.buildMisc(state, subpop, threadnum)) != 1)</span>
<span class="nc" id="L409">                    state.output.fatal(&quot;Whoa! Breeding Source for subpop &quot; + subpop + &quot; is not producing one individual at a time, as is required by the MuLambda strategies.&quot;);</span>

                // increment the count
<span class="nc" id="L412">                count[threadnum]++;</span>
                }
<span class="nc" id="L414">            bp.finishProducing(state,subpop,threadnum);</span>
            }
<span class="nc" id="L416">        }</span>
    }


/** A private helper class for implementing multithreaded breeding */
<span class="nc" id="L421">class MuLambdaBreederThread implements Runnable</span>
    {
    Population newpop;
    public int[] numinds;
    public int[] from;
    public MuCommaLambdaBreeder me;
    public EvolutionState state;
    public int threadnum;
    public void run()
        {
<span class="nc" id="L431">        me.breedPopChunk(newpop,state,numinds,from,threadnum);</span>
<span class="nc" id="L432">        }</span>
    }


</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>