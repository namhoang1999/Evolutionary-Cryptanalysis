<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Slave.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">ecj</a> &gt; <a href="index.source.html" class="el_package">ec.eval</a> &gt; <span class="el_source">Slave.java</span></div><h1>Slave.java</h1><pre class="source lang-java linenums">/*
  Copyright 2006 by Sean Paus, Sean Luke, and George Mason University
  Licensed under the Academic Free License version 3.0
  See the file &quot;LICENSE&quot; for more information
*/


/*
 * Created on Oct 8, 2004
 */
package ec.eval;

import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.ConnectException;
import java.net.Socket;
import java.net.UnknownHostException;
import java.util.ArrayList;

import ec.*;
import ec.coevolve.GroupedProblemForm;
import ec.simple.SimpleProblemForm;
import ec.util.*;

/**
 * Slave.java
 *
 
 &lt;p&gt;Slave is the main entry point for a slave evaluation process.  The slave works with a master process,
 receiving individuals from the master, evaluating them, and reporting the results back to the master, thus
 enabling distributed evolution.  
 
 &lt;p&gt;Slave replicates most of the functionality of
 the ec.Evolve class, for example in terms of parameters and checkpointing.  This is mostly because it needs
 to bootstrap and set up the EvolutionState in much the same way that ec.Evolve does.  Additionally, depending
 on settings below, the Slave may act like a mini-evolver on the individuals it receives from the master.
 
 &lt;p&gt;Like ec.Evolve, Slave is run with like this:
 
 &lt;p&gt;&lt;tt&gt;java ec.eval.Slave -file &lt;/tt&gt;&lt;i&gt;parameter_file [&lt;/i&gt;&lt;tt&gt;-p &lt;/tt&gt;&lt;i&gt;parameter=value]*&lt;/i&gt;
 
 &lt;p&gt;This starts a new slave, using the parameter file &lt;i&gt;parameter_file&lt;/i&gt;.
 The user can provide optional overriding parameters on the command-line with the &lt;tt&gt;-p&lt;/tt&gt; option.
 
 &lt;p&gt;Slaves need to know some things in order to run: the master's IP address and socket port number,
 whether to do compression, and whether or not to return individuals or just fitnesses.  Unfortunately, 
 Sun's CompressedInputStream/CompressedOutputStream is broken (it doesn't allow partial flushes, which
 is critical for doing compressed network streams).  In order to do compression, you need to download the
 JZLIB library from the ECJ website or from http://www.jcraft.com/jzlib/  .  ECJ will detect and use it
 automatically.
 
 &lt;p&gt;Slaves presently always run in single-threaded mode and receive their random number generator seed
 from the master.  Thus they ignore any seed parameters given to them.
 
 &lt;p&gt;Slaves run in one of three modes:
 
 &lt;ul&gt;
 &lt;p&gt;&lt;li&gt;&quot;Regular&quot; mode, which does a loop where it receives N individuals, evaluates them, and
 returns either the individuals or their new fitnesses.
 &lt;p&gt;&lt;li&gt;&quot;Regular Coevolutionary&quot; mode, which does a loop where it receives N individuals to assess together in
 a single coevolutionary evaluation, evaluates them, and returns either the individuals or their new fitnesses
 (or only some fitnesses if only some are requested).
 &lt;p&gt;&lt;li&gt;&quot;Evolve&quot; mode, which does a loop where it receives
 N individuals, evaluates them, and if there's some more time left, does a little evolution on those individuals as
 if they were a population, then when the time is up, the current individuals in the population are returned in lieu
 of the original individuals.  In this second form, individuals MUST be returned, not fitnesses.  This mode is not
 available if you're doing coevolution.
 &lt;/ul&gt;
 
 &lt;p&gt;&lt;b&gt;Parameters&lt;/b&gt;&lt;br&gt;
 &lt;table&gt;
 
 &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;eval.slave-name&lt;/tt&gt;&lt;br&gt;
 &lt;font size=-1&gt; String &lt;/font&gt;&lt;/td&gt;
 &lt;td valign=top&gt;(the slave's name, only for debugging purposes.  If not specified, the slave makes one up.)&lt;/td&gt;&lt;/tr&gt;

 &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;eval.master.host&lt;/tt&gt;&lt;br&gt;
 &lt;font size=-1&gt; String &lt;/font&gt;&lt;/td&gt;
 &lt;td valign=top&gt;(the IP Address of the master.)&lt;/td&gt;&lt;/tr&gt;

 &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;eval.master.port&lt;/tt&gt;&lt;br&gt;
 &lt;font size=-1&gt; integer &amp;gt;= 1024 &lt;/font&gt;&lt;/td&gt;
 &lt;td valign=top&gt;(the socket port number of the master.)&lt;/td&gt;&lt;/tr&gt;

 &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;eval.compression&lt;/tt&gt;&lt;br&gt;
 &lt;font size=-1&gt; bool = &lt;tt&gt;true&lt;/tt&gt; or &lt;tt&gt;false&lt;/tt&gt; (default) &lt;/font&gt;&lt;/td&gt;
 &lt;td valign=top&gt;(should we use compressed streams in communicating with the master?)&lt;/td&gt;&lt;/tr&gt;

 &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;eval.run-evolve&lt;/tt&gt;&lt;br&gt;
 &lt;font size=-1&gt; bool = &lt;tt&gt;true&lt;/tt&gt; or &lt;tt&gt;false&lt;/tt&gt; (default) &lt;/font&gt;&lt;/td&gt;
 &lt;td valign=top&gt;(should we immediately evaluate the individuals and return them (or their fitnesses), or if we have extra time (defined by eval.runtime),
 should we do a little evolution on our individuals first?)&lt;/td&gt;&lt;/tr&gt;

 &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;eval.runtime&lt;/tt&gt;&lt;br&gt;
 &lt;font size=-1&gt; integer &amp;gt; 0 &lt;/font&gt;&lt;/td&gt;
 &lt;td valign=top&gt;(if eval.run-evolve is true, how long (in milliseconds wall-clock time) should we allow the individuals to evolve?)&lt;/td&gt;&lt;/tr&gt;

 &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;eval.return-inds&lt;/tt&gt;&lt;br&gt;
 &lt;font size=-1&gt; bool = &lt;tt&gt;true&lt;/tt&gt; or &lt;tt&gt;false&lt;/tt&gt; (default) &lt;/font&gt;&lt;/td&gt;
 &lt;td valign=top&gt;(should we return whole individuals or (if false) just the fitnesses of the individuals?  This must be TRUE if eval.run-evolve is true.)&lt;/td&gt;&lt;/tr&gt;

 &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;eval.one-shot&lt;/tt&gt;&lt;br&gt;
 &lt;font size=-1&gt; bool = &lt;tt&gt;true&lt;/tt&gt; (default) or &lt;tt&gt;false&lt;/tt&gt;&lt;/font&gt;&lt;/td&gt;
 &lt;td valign=top&gt;(Should the slave quit when the master quits, or loop continuously in the background processing new masters?)&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 
 * 
 * @author Liviu Panait, Sean Paus, Keith Sullivan, and Sean Luke
 */
 
 
 
<span class="nc" id="L117">public class Slave </span>
    {
    public final static String P_EVALNODELAY = &quot;eval.no-delay&quot;;

    public final static String P_EVALSENDBUFER = &quot;eval.send-buffer&quot;;

    public final static String P_EVALRECVBUFFER = &quot;eval.recv-buffer&quot;;

    public final static String P_EVALSLAVENAME = &quot;eval.slave.name&quot;;
        
    public final static String P_EVALMASTERHOST = &quot;eval.master.host&quot;;
        
    public final static String P_EVALMASTERPORT = &quot;eval.master.port&quot;;
        
    public final static String P_EVALCOMPRESSION = &quot;eval.compression&quot;;
    
    public final static String P_RETURNINDIVIDUALS = &quot;eval.return-inds&quot;;

    public final static String P_SILENT = &quot;eval.slave.silent&quot;;
    public final static String P_MUZZLE = &quot;eval.slave.muzzle&quot;;
            
    public static final byte V_NOTHING = 0;
    public static final byte V_INDIVIDUAL = 1;
    public static final byte V_FITNESS = 2;
        
    public static final byte V_SHUTDOWN = 0;
    public static final byte V_EVALUATESIMPLE = 1;
    public static final byte V_EVALUATEGROUPED = 2;

    /** The argument indicating that we're starting fresh from a parameter file stored in a jar file or as some resource. */
    public static final String A_FROM = &quot;-from&quot;;

    /** The argument indicating the class where the resource is relative to. */
    public static final String A_AT = &quot;-at&quot;;

    /** The argument indicating that we're starting fresh from a new parameter file. */
    public static final String A_FILE = &quot;-file&quot;;
        
    /** Time to run evolution on the slaves in seconds */ 
    public static final String P_RUNTIME = &quot;eval.slave.runtime&quot;; 
<span class="nc" id="L157">    public static int runTime=0; </span>
        
    /** Should slave run its own evolutionary process? */ 
    public static final String P_RUNEVOLVE = &quot;eval.slave.run-evolve&quot;; 
<span class="nc" id="L161">    public static boolean runEvolve=false; </span>
        
    /** Should slave go into an infinite loop looking for new masters after the master has quit, or not? */
    public static final String P_ONESHOT = &quot;eval.slave.one-shot&quot;; 
<span class="nc" id="L165">    public static boolean oneShot=false; </span>
        
    /** How long we sleep in between attempts to connect to the master (in milliseconds). */
    public static final int SLEEP_TIME = 100;
        
<span class="nc" id="L170">    public static final ThreadPool pool = new ThreadPool();</span>
    
    /** My unique slave number. At present this is just used to define a unique name. */
<span class="nc" id="L173">    public static int slaveNum = -1;</span>

    public static void main(String[] args)
        {
<span class="nc" id="L177">        EvolutionState state = null;</span>
<span class="nc" id="L178">        ParameterDatabase parameters = null;</span>
<span class="nc" id="L179">        Output output = null;</span>
                
        // 0. find the parameter database
<span class="nc bnc" id="L182" title="All 2 branches missed.">        for (int x = 0; x &lt; args.length - 1; x++)</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">            if (args[x].equals(A_FILE))</span>
                try
                    {
<span class="nc" id="L186">                    parameters = new ParameterDatabase(</span>
<span class="nc" id="L187">                        new File(new File(args[x + 1]).getAbsolutePath()),</span>
                        args);
                                                
                    // add the fact that I am a slave:      eval.i-am-slave = true
                    // this is used only by the Evaluator to determine whether to use the MasterProblem
<span class="nc" id="L192">                    parameters.set(new Parameter(ec.EvolutionState.P_EVALUATOR).push(ec.Evaluator.P_IAMSLAVE), &quot;true&quot;);</span>
<span class="nc" id="L193">                    break;</span>
                    }
<span class="nc" id="L195">                catch(Exception e)</span>
                    {
<span class="nc" id="L197">                    e.printStackTrace();</span>
<span class="nc" id="L198">                    Output.initialError(&quot;An exception was generated upon reading the parameter file \&quot;&quot; + args[x+1] + &quot;\&quot;.\nHere it is:\n&quot; + e, true); </span>
                    }
        
        // search for a resource class (we may or may not use this)
<span class="nc" id="L202">        Class cls = null;</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">        for(int x=0;x&lt;args.length-1;x++)</span>
<span class="nc bnc" id="L204" title="All 2 branches missed.">            if (args[x].equals(A_AT))</span>
                try
                    {
<span class="nc bnc" id="L207" title="All 2 branches missed.">                    if (parameters != null)  // uh oh</span>
<span class="nc" id="L208">                        Output.initialError(&quot;Both -from and -at arguments provided.  This is not permitted.\nFor help, try:  java ec.Evolve -help&quot;, true);</span>
                    else 
<span class="nc" id="L210">                        cls = Class.forName(args[x+1]);</span>
<span class="nc" id="L211">                    break;</span>
                    }
<span class="nc" id="L213">                catch (Exception e)</span>
                    {
<span class="nc" id="L215">                    e.printStackTrace();</span>
<span class="nc" id="L216">                    Output.initialError(</span>
                        &quot;An exception was generated upon extracting the class to load the parameter file relative to: &quot; + args[x+1] + 
                        &quot;\nFor help, try:  java ec.Evolve -help\n\n&quot; + e, true);
                    }
                    
        // search for a resource (we may or may not use this)
<span class="nc bnc" id="L222" title="All 2 branches missed.">        for(int x=0;x&lt;args.length-1;x++)</span>
<span class="nc bnc" id="L223" title="All 2 branches missed.">            if (args[x].equals(A_FROM))</span>
                try
                    {
<span class="nc bnc" id="L226" title="All 2 branches missed.">                    if (parameters != null)  // uh oh</span>
<span class="nc" id="L227">                        Output.initialError(&quot;Both -file and -from arguments provided.  This is not permitted.\nFor help, try:  java ec.Evolve -help&quot;, true);</span>
                    else 
                        {
<span class="nc bnc" id="L230" title="All 2 branches missed.">                        if (cls == null)  // no -at</span>
<span class="nc" id="L231">                            cls = Evolve.class;</span>
<span class="nc" id="L232">                        parameters = new ParameterDatabase(args[x+1], cls, args);</span>
<span class="nc" id="L233">                        Output.initialMessage(&quot;Using database resource location &quot; + parameters.getLabel());</span>
                        }
                        
                    // add the fact that I am a slave:      eval.i-am-slave = true
                    // this is used only by the Evaluator to determine whether to use the MasterProblem
<span class="nc" id="L238">                    parameters.set(new Parameter(ec.EvolutionState.P_EVALUATOR).push(ec.Evaluator.P_IAMSLAVE), &quot;true&quot;);</span>
<span class="nc" id="L239">                    break;</span>
                    }
<span class="nc" id="L241">                catch (Exception e)</span>
                    {
<span class="nc" id="L243">                    e.printStackTrace();</span>
<span class="nc" id="L244">                    Output.initialError(</span>
                        &quot;The parameter file is missing at the resource location: &quot; + args[x+1] + &quot; relative to the class: &quot; + cls + &quot;\n\nFor help, try:  java ec.Evolve -help&quot;, true);
                    }

        
        
<span class="nc bnc" id="L250" title="All 2 branches missed.">        if (parameters == null)</span>
<span class="nc" id="L251">            Output.initialError(&quot;No parameter file was specified.&quot;, true ); </span>
                
        // 5. Determine whether or not to return entire Individuals or just Fitnesses
        //    (plus whether or not the Individual has been evaluated).
        
<span class="nc" id="L256">        boolean returnIndividuals = parameters.getBoolean(new Parameter(P_RETURNINDIVIDUALS),null,false);</span>
                
        // 5.5 should we silence the whole thing?

<span class="nc" id="L260">        boolean silent = parameters.getBoolean(new Parameter(P_SILENT), null, false);</span>

<span class="nc bnc" id="L262" title="All 2 branches missed.">        if (parameters.exists(new Parameter(P_MUZZLE), null))</span>
<span class="nc" id="L263">            Output.initialWarning(&quot;&quot; + new Parameter(P_MUZZLE) + &quot; has been deprecated.  We suggest you use &quot; + </span>
                new Parameter(P_SILENT) + &quot; or similar newer options.&quot;);
<span class="nc bnc" id="L265" title="All 4 branches missed.">        silent = silent || parameters.getBoolean(new Parameter(P_MUZZLE), null, false);</span>

                
        // 6. Open a socket and listen for requests
<span class="nc" id="L269">        String slaveName = parameters.getString(</span>
            new Parameter(P_EVALSLAVENAME),null);
                
<span class="nc" id="L272">        String masterHost = parameters.getString(</span>
            new Parameter(P_EVALMASTERHOST),null );
<span class="nc bnc" id="L274" title="All 2 branches missed.">        if (masterHost == null)</span>
<span class="nc" id="L275">            Output.initialError(&quot;Master Host missing&quot;, new Parameter(P_EVALMASTERHOST), true);</span>
<span class="nc" id="L276">        int masterPort = parameters.getInt(</span>
            new Parameter(P_EVALMASTERPORT),null, 0);
<span class="nc bnc" id="L278" title="All 2 branches missed.">        if (masterPort == -1)</span>
<span class="nc" id="L279">            Output.initialError(&quot;Master Port missing&quot;, new Parameter(P_EVALMASTERPORT), true);</span>
                
<span class="nc" id="L281">        runTime = parameters.getInt(new Parameter(P_RUNTIME), null, 0); </span>
                
<span class="nc" id="L283">        runEvolve = parameters.getBoolean(new Parameter(P_RUNEVOLVE),null,false); </span>

<span class="nc" id="L285">        oneShot = parameters.getBoolean(new Parameter(P_ONESHOT),null,true); </span>
        
<span class="nc bnc" id="L287" title="All 2 branches missed.">        final int noDelay = parameters.exists(new Parameter(P_EVALNODELAY), null) ? </span>
<span class="nc bnc" id="L288" title="All 2 branches missed.">        	(parameters.getBoolean(new Parameter(P_EVALNODELAY), null, true) ? 1 : 0) : -1;</span>

<span class="nc" id="L290">        final int sendbuffer = parameters.getInt(new Parameter(P_EVALSENDBUFER), null, -1); </span>
<span class="nc" id="L291">        final int recvbuffer = parameters.getInt(new Parameter(P_EVALRECVBUFFER), null, -1); </span>
        
<span class="nc bnc" id="L293" title="All 4 branches missed.">        if (runEvolve &amp;&amp; !returnIndividuals)</span>
            {
<span class="nc" id="L295">            Output.initialError(&quot;You have the slave running in 'evolve' mode, but it's only returning fitnesses to the master, not whole individuals.  This is almost certainly wrong.&quot;,</span>
                new Parameter(P_RUNEVOLVE), new Parameter(P_RETURNINDIVIDUALS), true);
            }
        
<span class="nc bnc" id="L299" title="All 2 branches missed.">        if (!silent) </span>
            {
<span class="nc" id="L301">            Output.initialMessage(&quot;ECJ Slave&quot;);</span>
<span class="nc bnc" id="L302" title="All 2 branches missed.">            if (runEvolve) Output.initialMessage(&quot;Running in Evolve mode, evolve time is &quot; + runTime + &quot; milliseconds&quot;);</span>
<span class="nc bnc" id="L303" title="All 2 branches missed.">            if (returnIndividuals) Output.initialMessage(&quot;Whole individuals will be returned&quot;);</span>
<span class="nc" id="L304">            else Output.initialMessage(&quot;Only fitnesses will be returned&quot;);</span>
            }
        
        // Continue to serve new masters until killed.
<span class="nc" id="L308">        Socket socket = null;</span>
        while (true)
            {
            try
                {
                try
                    {
<span class="nc" id="L315">                    long connectAttemptCount = 0;</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">                    if (!silent) Output.initialMessage(&quot;Connecting to master at &quot;+masterHost+&quot;:&quot;+masterPort);</span>
                    while (true)
                        {
                        try
                            {
<span class="nc" id="L321">                            socket = new Socket(masterHost, masterPort);</span>
<span class="nc" id="L322">                            break;</span>
                            }
<span class="nc" id="L324">                        catch (ConnectException e)   // it's not up yet...</span>
                            {
<span class="nc" id="L326">                            connectAttemptCount++;</span>
                            try
                                {
<span class="nc" id="L329">                                Thread.sleep(SLEEP_TIME);</span>
                                }
<span class="nc" id="L331">                            catch( InterruptedException f )</span>
                                {
<span class="nc" id="L333">                                }</span>
<span class="nc" id="L334">                            }</span>
                        }
<span class="nc bnc" id="L336" title="All 2 branches missed.">                    if (!silent) Output.initialMessage(&quot;Connected to master after &quot; + (connectAttemptCount * SLEEP_TIME) + &quot; ms&quot;);</span>
                    
<span class="nc" id="L338">                    DataInputStream dataIn = null;</span>
<span class="nc" id="L339">                    DataOutputStream dataOut = null;</span>

                    try
                        {
<span class="nc bnc" id="L343" title="All 2 branches missed.">                        if (noDelay == 1)</span>
                        	{
<span class="nc" id="L345">                        	socket.setTcpNoDelay(true);</span>
<span class="nc bnc" id="L346" title="All 2 branches missed.">                        	if (!silent) </span>
<span class="nc" id="L347">                        	Output.initialMessage(&quot;NoDelay -&gt; ON&quot;);</span>
                        	}
<span class="nc bnc" id="L349" title="All 2 branches missed.">                        else if (noDelay == 0)</span>
                        	{
<span class="nc" id="L351">                        	socket.setTcpNoDelay(false);</span>
<span class="nc bnc" id="L352" title="All 2 branches missed.">                        	if (!silent) </span>
<span class="nc" id="L353">                        	Output.initialMessage(&quot;NoDelay -&gt; OFF&quot;);</span>
                        	}

<span class="nc bnc" id="L356" title="All 2 branches missed.">                        if (sendbuffer &gt;= 0)</span>
                        	{
<span class="nc bnc" id="L358" title="All 2 branches missed.">                        	if (!silent) </span>
<span class="nc" id="L359">                        	Output.initialMessage(&quot;SendBuffer -&gt; &quot; + sendbuffer + &quot; was &quot; + socket.getSendBufferSize());</span>
<span class="nc" id="L360">                        	socket.setSendBufferSize(sendbuffer);</span>
                        	}
                        
<span class="nc bnc" id="L363" title="All 2 branches missed.">                        if (recvbuffer &gt;= 0)</span>
                        	{
<span class="nc bnc" id="L365" title="All 2 branches missed.">                        	if (!silent) </span>
<span class="nc" id="L366">                        	Output.initialMessage(&quot;RecvBuffer -&gt; &quot; + recvbuffer + &quot; was &quot; + socket.getReceiveBufferSize());</span>
<span class="nc" id="L367">                        	socket.setReceiveBufferSize(recvbuffer);</span>
                        	}
                        	
<span class="nc" id="L370">                        InputStream tmpIn = socket.getInputStream();</span>
<span class="nc" id="L371">                        OutputStream tmpOut = socket.getOutputStream();</span>
                        
                        // The first thing we do is read a single byte telling us whether to use compression or nt
<span class="nc bnc" id="L374" title="All 2 branches missed.">                        boolean useCompression = (tmpIn.read() != 0);</span>
                        
<span class="nc bnc" id="L376" title="All 2 branches missed.">                        if (useCompression)</span>
                            {
<span class="nc" id="L378">                            tmpIn = Output.makeCompressingInputStream(tmpIn);</span>
<span class="nc" id="L379">                            tmpOut = Output.makeCompressingOutputStream(tmpOut);</span>
<span class="nc bnc" id="L380" title="All 4 branches missed.">                            if (tmpIn == null || tmpOut == null)</span>
                                {
<span class="nc" id="L382">                                String err = &quot;You do not appear to have JZLib installed on your system, and so must set eval.compression=false.  &quot; +</span>
                                    &quot;To get JZLib, download from the ECJ website or from http://www.jcraft.com/jzlib/&quot;;
<span class="nc bnc" id="L384" title="All 2 branches missed.">                                if (!silent) Output.initialMessage(err);</span>
<span class="nc" id="L385">                                throw new Output.OutputExitException(err);</span>
                                }
                            }
                                                
<span class="nc" id="L389">                        dataIn = new DataInputStream(tmpIn);</span>
<span class="nc" id="L390">                        dataOut = new DataOutputStream(tmpOut);</span>
                        }
<span class="nc" id="L392">                    catch (IOException e)</span>
                        {
<span class="nc" id="L394">                        String err = &quot;Unable to open input stream from socket:\n&quot;+e;</span>
<span class="nc bnc" id="L395" title="All 2 branches missed.">                        if (!silent) Output.initialMessage(err);</span>
<span class="nc" id="L396">                        throw new Output.OutputExitException(err);</span>
<span class="nc" id="L397">                        }</span>
                        
                    // read the unique number assigned to me
<span class="nc" id="L400">                    slaveNum = dataIn.readInt();</span>
                                
                    // specify the slaveName
<span class="nc bnc" id="L403" title="All 2 branches missed.">                    if (slaveName==null)</span>
                        {                    
<span class="nc" id="L405">                        slaveName = socket.getLocalAddress().toString() + &quot;/&quot; + slaveNum;</span>
<span class="nc bnc" id="L406" title="All 2 branches missed.">                        if (!silent) Output.initialMessage(&quot;No slave name specified.  Using: &quot; + slaveName);</span>
                        }
<span class="nc" id="L408">                    Output.initialMessage(&quot;I am slave &quot; + slaveName);</span>
                                
<span class="nc" id="L410">                    dataOut.writeUTF(slaveName);</span>
<span class="nc" id="L411">                    dataOut.flush();</span>

                    // 1. create the output
                    // store = parameters.getBoolean(new Parameter(P_STORE), null, false);
                
<span class="nc bnc" id="L416" title="All 2 branches missed.">                    if (output != null) output.close();</span>
<span class="nc" id="L417">                    output = new Output(false);              // do not store messages, just print them</span>
<span class="nc" id="L418">                    output.setThrowsErrors(true);  			 // don't do System.exit(1);</span>
                
                    // stdout is always log #0. stderr is always log #1.
                    // stderr accepts announcements, and both are fully verbose
                    // by default.
<span class="nc" id="L423">                    output.addLog(ec.util.Log.D_STDOUT, false);</span>
<span class="nc" id="L424">                    output.addLog(ec.util.Log.D_STDERR, true);</span>

<span class="nc bnc" id="L426" title="All 2 branches missed.">                    if (silent)</span>
                        {
<span class="nc" id="L428">                        output.getLog(0).silent = true;</span>
<span class="nc" id="L429">                        output.getLog(1).silent = true;</span>
                        }

<span class="nc bnc" id="L432" title="All 2 branches missed.">                    if (!silent) output.systemMessage(Version.message());</span>


                    // 2. set up thread values
<span class="nc" id="L436">                    int breedthreads = Evolve.determineThreads(output, parameters, new Parameter(Evolve.P_BREEDTHREADS));</span>
<span class="nc" id="L437">                    int evalthreads = Evolve.determineThreads(output, parameters, new Parameter(Evolve.P_EVALTHREADS));</span>

                    // Note that either breedthreads or evalthreads (or both) may be 'auto'.  We don't warn about this because
                    // the user isn't providing the thread seeds.
                

                    // 3. create the Mersenne Twister random number generators,
                    // one per thread

<span class="nc bnc" id="L446" title="All 2 branches missed.">                    MersenneTwisterFast[] random = new MersenneTwisterFast[breedthreads &gt; evalthreads ? </span>
<span class="nc" id="L447">                        breedthreads : evalthreads];</span>
        
<span class="nc" id="L449">                    int seed = dataIn.readInt();</span>
<span class="nc bnc" id="L450" title="All 2 branches missed.">                    for(int i = 0; i &lt; random.length; i++)</span>
<span class="nc" id="L451">                        random[i] = Evolve.primeGenerator(new MersenneTwisterFast(seed++));  // we prime the generator to be more sure of randomness.</span>

                    // 4. Set up the evolution state
                
                    // what evolution state to use?
<span class="nc" id="L456">                    state = (EvolutionState)</span>
<span class="nc" id="L457">                        parameters.getInstanceForParameter(new Parameter(ec.Evolve.P_STATE),null,</span>
                            EvolutionState.class);
<span class="nc" id="L459">                    state.parameters = new ParameterDatabase();</span>
<span class="nc" id="L460">                    state.parameters.addParent(parameters);</span>
<span class="nc" id="L461">                    state.random = random;</span>
<span class="nc" id="L462">                    state.output = output;</span>
<span class="nc" id="L463">                    state.evalthreads = evalthreads;</span>
<span class="nc" id="L464">                    state.breedthreads = breedthreads;</span>
        
<span class="nc" id="L466">                    state.setup(state, null);</span>
<span class="nc" id="L467">                    state.population = state.initializer.setupPopulation(state, 0);</span>
                
                    // 5. Optionally do further loading
<span class="nc" id="L470">                    final MasterProblem storage = state.evaluator.masterproblem;</span>
<span class="nc" id="L471">                    storage.receiveAdditionalData(state, dataIn);</span>
<span class="nc" id="L472">                    storage.transferAdditionalData(state);</span>
                    
                    try
                        {
                        while (true)
                            {
<span class="nc" id="L478">                            EvolutionState newState = state;</span>

<span class="nc bnc" id="L480" title="All 2 branches missed.">                            if (runEvolve) </span>
                                {
                                // Construct and use a new EvolutionState.  This will be inefficient the first time around
                                // as we've set up TWO EvolutionStates in a row with no good reason.
<span class="nc" id="L484">                                ParameterDatabase coverDatabase = new ParameterDatabase();  // protect the underlying one</span>
<span class="nc" id="L485">                                coverDatabase.addParent(state.parameters);</span>
<span class="nc" id="L486">                                newState = (EvolutionState) Evolve.initialize(coverDatabase, 0);</span>
<span class="nc" id="L487">                                newState.startFresh();</span>
<span class="nc" id="L488">                                newState.output.message(&quot;Replacing random number generators, ignore above seed message&quot;);</span>
<span class="nc" id="L489">                                newState.random = state.random;  // continue with RNG</span>
<span class="nc" id="L490">                                storage.transferAdditionalData(newState);  // load the arbitrary data again</span>
                                }
                        
                            // 0 means to shut down
<span class="nc" id="L494">                            int problemType = dataIn.readByte();</span>
<span class="nc bnc" id="L495" title="All 4 branches missed.">                            switch (problemType)</span>
                                {
                                case V_SHUTDOWN:
                                    {
<span class="nc" id="L499">                                    socket.close();</span>
<span class="nc bnc" id="L500" title="All 2 branches missed.">                                    if (oneShot)</span>
<span class="nc" id="L501">                                        return;  // we're outa here</span>
                                    else
<span class="nc" id="L503">                                        throw new Output.OutputExitException(&quot;SHUTDOWN&quot;);</span>
                                    }
                                case V_EVALUATESIMPLE:
<span class="nc" id="L506">                                    evaluateSimpleProblemForm(newState, returnIndividuals, dataIn, dataOut, args);</span>
<span class="nc" id="L507">                                    break;</span>
                                case V_EVALUATEGROUPED:
<span class="nc" id="L509">                                    evaluateGroupedProblemForm(newState, returnIndividuals, dataIn, dataOut);</span>
<span class="nc" id="L510">                                    break;</span>
                                default:
<span class="nc" id="L512">                                    state.output.fatal(&quot;Unknown problem form specified: &quot;+problemType);</span>
                                }
<span class="nc" id="L514">                            }</span>

                        } 
<span class="nc" id="L517">                    catch (Exception e)    </span>
                        {
                        // Since an IOException can happen here if the peer closes the socket
                        // on it's end, we don't necessarily have to exit.  Maybe we don't
                        // even need to print a warning, but we'll do so just to indicate
                        // something happened.
<span class="nc" id="L523">                        state.output.fatal(&quot;Unable to read type of evaluation from master.  Maybe the master closed its socket and exited?:\n&quot; + e);</span>
                        }
                    } 
<span class="nc" id="L526">                catch (UnknownHostException e)</span>
                    {
<span class="nc bnc" id="L528" title="All 2 branches missed.">                    if (state != null)</span>
<span class="nc" id="L529">                        state.output.fatal(e.getMessage());</span>
<span class="nc bnc" id="L530" title="All 2 branches missed.">                    else if (!silent) Output.initialError(&quot;FATAL ERROR (EvolutionState not created yet): &quot; + e.getMessage(), true);</span>
                    }
<span class="nc" id="L532">                catch (IOException e)</span>
                    {
<span class="nc bnc" id="L534" title="All 2 branches missed.">                    if (state != null)</span>
<span class="nc" id="L535">                        state.output.fatal(&quot;Unable to connect to master:\n&quot; + e);</span>
<span class="nc bnc" id="L536" title="All 2 branches missed.">                    else if (!silent) Output.initialError(&quot;FATAL ERROR (EvolutionState not created yet): &quot; + e, true);</span>
<span class="nc" id="L537">                    }</span>
                }
<span class="nc" id="L539">            catch (Output.OutputExitException e)</span>
                {
                // here we restart if necessary
<span class="nc" id="L542">                try { socket.close(); } catch (Exception e2) { }</span>
<span class="nc bnc" id="L543" title="All 2 branches missed.">                if (oneShot) { throw e; }</span>
                }
<span class="nc" id="L545">            catch (OutOfMemoryError e)</span>
                {
<span class="nc" id="L547">                try { socket.close(); } catch (Exception e2) { }</span>
<span class="nc bnc" id="L548" title="All 2 branches missed.">                if (oneShot) { throw e; }</span>
                
                // Otherwise let's try fixing things.  This will probably fail
<span class="nc" id="L551">                socket = null;</span>
<span class="nc" id="L552">                state = null;</span>
<span class="nc" id="L553">                System.gc();</span>
<span class="nc" id="L554">                System.err.println(e);</span>
<span class="nc" id="L555">                }</span>
                
<span class="nc bnc" id="L557" title="All 4 branches missed.">            if (oneShot) { if (!silent) Output.initialMessage(&quot;\n\nExiting Slave: this shouldn't have happened&quot;); }		// we shouldn't be able to get here</span>
            
<span class="nc bnc" id="L559" title="All 2 branches missed.">            if (!silent) Output.initialMessage(&quot;\n\nResetting Slave&quot;);</span>
            }
        }
                            
    public static void evaluateSimpleProblemForm( final EvolutionState state, boolean returnIndividuals,
        DataInputStream dataIn, DataOutputStream dataOut, String[] args )
        {
        // first load the individuals
<span class="nc" id="L567">        int numInds=1; </span>
        try
            {
<span class="nc" id="L570">            numInds = dataIn.readInt();</span>
            }
<span class="nc" id="L572">        catch (Exception e)</span>
            {
<span class="nc" id="L574">            state.output.fatal(&quot;Unable to read the number of individuals from the master:\n&quot;+e);</span>
<span class="nc" id="L575">            }</span>
        
        // load the subpops 
<span class="nc" id="L578">        final int[] subpops = new int[numInds];  // subpops desired by each ind</span>
<span class="nc" id="L579">        int[] indsPerSubpop = new int[state.population.subpops.size()];  // num inds for each subpop</span>
<span class="nc bnc" id="L580" title="All 2 branches missed.">        for(int i = 0; i &lt; numInds; i++)</span>
            {
            try
                {
<span class="nc" id="L584">                subpops[i] = dataIn.readInt();</span>
<span class="nc bnc" id="L585" title="All 4 branches missed.">                if (subpops[i] &lt; 0 || subpops[i] &gt;= state.population.subpops.size())</span>
<span class="nc" id="L586">                    state.output.fatal(&quot;Bad subpop number for individual #&quot; + i + &quot;: &quot; + subpops[i]);</span>
<span class="nc" id="L587">                indsPerSubpop[subpops[i]]++;</span>
                }
<span class="nc" id="L589">            catch (Exception e)</span>
                {
<span class="nc" id="L591">                state.output.fatal(&quot;Unable to read the subpop number from the master:\n&quot;+e);</span>
<span class="nc" id="L592">                }</span>
            }
        
                
        // Read the individual(s) from the stream and evaluate 
        
<span class="nc" id="L598">        boolean[] updateFitness = new boolean[numInds];</span>
<span class="nc" id="L599">        final Individual[] inds = new Individual[numInds];</span>
        
        // Either evaluate all the individuals once and return them immediately
        // (we'll do so in a steady-state-ish fashion, firing off threads as soon as we read in individuals,
        // and returning them as soon as they come in, albeit in the proper order)
<span class="nc bnc" id="L604" title="All 2 branches missed.">        if (!runEvolve)</span>
            {
<span class="nc" id="L606">            ThreadPool.Worker[] threads = new ThreadPool.Worker[state.evalthreads];</span>
<span class="nc" id="L607">            final SimpleProblemForm[] problems = new SimpleProblemForm[state.evalthreads];</span>
<span class="nc" id="L608">            int[] indForThread = new int[state.evalthreads];</span>
           
           	// build the problems
<span class="nc bnc" id="L611" title="All 2 branches missed.">           	for(int i = 0; i &lt; problems.length; i++)</span>
           		{
<span class="nc" id="L613">           		problems[i] = ((SimpleProblemForm)(state.evaluator.p_problem.clone()));</span>
           		}
           		
<span class="nc" id="L616">            int t = 0;              // thread index            </span>
            try
                {
<span class="nc bnc" id="L619" title="All 2 branches missed.">                for(int i = 0 ; i &lt; numInds; i++)</span>
                    {
                    // load individual
<span class="nc" id="L622">                    inds[i] = state.population.subpops.get(subpops[i]).species.newIndividual(state, dataIn);</span>
<span class="nc" id="L623">                    updateFitness[i] = dataIn.readBoolean(); </span>

                    // get next thread index
<span class="nc bnc" id="L626" title="All 2 branches missed.">                    if (t &gt;= state.evalthreads) t = 0;       // we can only be here if evalthreads &gt; numInds</span>
                    
                    // Does a thread exist?  Wait for him and process
<span class="nc bnc" id="L629" title="All 2 branches missed.">                    if (threads[t] != null)</span>
                        {
<span class="nc" id="L631">                        pool.join(threads[t]);  // ran out of threads, wait for new ones</span>
<span class="nc" id="L632">                        returnIndividualsToMaster(state, inds, updateFitness, dataOut, returnIndividuals, indForThread[t]);  // return just that individual</span>
                        }

					// Assign new thread to problem
<span class="nc" id="L636">                    final int _i = i;</span>
<span class="nc" id="L637">                    final int _t = t;</span>
<span class="nc" id="L638">                    indForThread[t] = i;</span>
<span class="nc" id="L639">                    threads[t] = pool.start(new Runnable()</span>
<span class="nc" id="L640">                        {</span>
<span class="nc" id="L641">                        public void run() { problems[_t].evaluate( state, inds[_i], subpops[_i], _t ); }</span>
                        }, &quot;Evaluation of individual &quot; + i);
<span class="nc" id="L643">                    t++;</span>
                    }
                                
                // gather everyone
<span class="nc bnc" id="L647" title="All 2 branches missed.">                for(t = 0; t &lt; state.evalthreads; t++)</span>
                    {
<span class="nc bnc" id="L649" title="All 2 branches missed.">                    if (threads[t] != null)</span>
                        {
<span class="nc" id="L651">                        pool.join(threads[t]);</span>
<span class="nc" id="L652">                        returnIndividualsToMaster(state, inds, updateFitness, dataOut, returnIndividuals, indForThread[t]);   // return just that individual</span>
                        }
                    }
                }
<span class="nc" id="L656">            catch (Exception e)</span>
                {
<span class="nc" id="L658">                state.output.fatal(&quot;Unable to read individual from master:\n&quot; + e);</span>
<span class="nc" id="L659">                }</span>
            try
                {
<span class="nc" id="L662">                dataOut.flush();</span>
                } 
<span class="nc" id="L664">            catch( IOException e ) { state.output.fatal(&quot;Caught fatal IOException:\n&quot;+e ); }</span>
<span class="nc" id="L665">            }</span>
                        
                        
                        
                
        // OR we will do some evolution.  Here we'll read in ALL the individuals, do some evolution, then
        // write them ALL out, very slightly less efficient
        else // (runEvolve) 
            {
            try             // load up all the individuals
                {
<span class="nc bnc" id="L676" title="All 2 branches missed.">                for (int i=0; i &lt; numInds; i++) </span>
                    { 
<span class="nc" id="L678">                    inds[i] = state.population.subpops.get(subpops[i]).species.newIndividual(state, dataIn);</span>
<span class="nc" id="L679">                    updateFitness[i] = dataIn.readBoolean(); </span>
                    }
                }
<span class="nc" id="L682">            catch (Exception e)</span>
                {
<span class="nc" id="L684">                state.output.fatal(&quot;Unable to read individual from master:\n&quot; + e);</span>
<span class="nc" id="L685">                }</span>
                        
                        
<span class="nc" id="L688">            long startTime = System.currentTimeMillis(); </span>
<span class="nc" id="L689">            long endTime=0; </span>

            // Now we need to reset the subpopulations.  They were already set up with the right
            // classes, Species, etc. in state.setup(), so all we need to do is modify the number
            // of individuals in each subpopulation.
        
<span class="nc bnc" id="L695" title="All 2 branches missed.">            for(int subpop = 0; subpop &lt; state.population.subpops.size(); subpop++)</span>
                {
<span class="nc bnc" id="L697" title="All 2 branches missed.">                if (state.population.subpops.get(subpop).individuals.size() != indsPerSubpop[subpop])</span>
<span class="nc" id="L698">                    state.population.subpops.get(subpop).individuals = new ArrayList&lt;Individual&gt;(indsPerSubpop[subpop]);</span>
                }
            
            // Disperse into the population
<span class="nc" id="L702">            int[] counts = new int[state.population.subpops.size()];</span>
<span class="nc bnc" id="L703" title="All 2 branches missed.">            for(int i =0; i &lt; numInds; i++)</span>
<span class="nc" id="L704">                state.population.subpops.get(subpops[i]).individuals.set(counts[subpops[i]]++,inds[i]);</span>
            
            // Evaluate the population until time is up, or the evolution stops
<span class="nc" id="L707">            int result = EvolutionState.R_NOTDONE; </span>
<span class="nc bnc" id="L708" title="All 2 branches missed.">            while (result == EvolutionState.R_NOTDONE) </span>
                { 
<span class="nc" id="L710">                result = state.evolve(); </span>
<span class="nc" id="L711">                endTime = System.currentTimeMillis(); </span>
<span class="nc bnc" id="L712" title="All 2 branches missed.">                if ((endTime - startTime) &gt; runTime) </span>
<span class="nc" id="L713">                    break;</span>
                }
                
            // re-gather from population in the same order
<span class="nc" id="L717">            counts = new int[state.population.subpops.size()];</span>
<span class="nc bnc" id="L718" title="All 2 branches missed.">            for(int i =0; i &lt; numInds; i++)</span>
<span class="nc" id="L719">                inds[i] = state.population.subpops.get(subpops[i]).individuals.get(counts[subpops[i]]++);</span>
<span class="nc" id="L720">            state.finish(result);</span>
<span class="nc" id="L721">            Evolve.cleanup(state);</span>

            // Return the evaluated individual to the master
            try 
                { 
<span class="nc" id="L726">                returnIndividualsToMaster(state, inds, updateFitness, dataOut, returnIndividuals, -1);  // -1 == write all individuals</span>
<span class="nc" id="L727">                dataOut.flush();</span>
                } 
<span class="nc" id="L729">            catch( IOException e ) { state.output.fatal(&quot;Caught fatal IOException\n&quot;+e ); }</span>
            }
<span class="nc" id="L731">        }</span>
    
        
        
        
        
        
        
        
    public static void evaluateGroupedProblemForm( EvolutionState state, boolean returnIndividuals,
        DataInputStream dataIn, DataOutputStream dataOut )
        {
<span class="nc" id="L743">        boolean countVictoriesOnly = false;</span>

        // first load the individuals
<span class="nc" id="L746">        int numInds = 1;</span>
        try
            {
<span class="nc" id="L749">            countVictoriesOnly = dataIn.readBoolean();</span>
<span class="nc" id="L750">            numInds = dataIn.readInt();</span>
            }
<span class="nc" id="L752">        catch (Exception e)</span>
            {
<span class="nc" id="L754">            state.output.fatal(&quot;Unable to read the number of individuals from the master:\n&quot;+e);</span>
<span class="nc" id="L755">            }</span>

        // load the subpops 
<span class="nc" id="L758">        int[] subpops = new int[numInds];  // subpops desired by each ind</span>
<span class="nc" id="L759">        int[] indsPerSubpop = new int[state.population.subpops.size()];  // num inds for each subpop</span>
<span class="nc bnc" id="L760" title="All 2 branches missed.">        for(int i = 0; i &lt; numInds; i++)</span>
            {
            try
                {
<span class="nc" id="L764">                subpops[i] = dataIn.readInt();</span>
<span class="nc bnc" id="L765" title="All 4 branches missed.">                if (subpops[i] &lt; 0 || subpops[i] &gt;= state.population.subpops.size())</span>
<span class="nc" id="L766">                    state.output.fatal(&quot;Bad subpop number for individual #&quot; + i + &quot;: &quot; + subpops[i]);</span>
<span class="nc" id="L767">                indsPerSubpop[subpops[i]]++;</span>
                }
<span class="nc" id="L769">            catch (Exception e)</span>
                {
<span class="nc" id="L771">                state.output.fatal(&quot;Unable to read the subpop number from the master:\n&quot;+e);</span>
<span class="nc" id="L772">                }</span>
            }

        // Read the individuals from the stream
<span class="nc" id="L776">        Individual inds[] = new Individual[numInds];</span>
<span class="nc" id="L777">        boolean updateFitness[] = new boolean[numInds];</span>
        try
            {
<span class="nc bnc" id="L780" title="All 2 branches missed.">            for(int i=0;i&lt;inds.length;++i)</span>
                {
<span class="nc" id="L782">                inds[i] = state.population.subpops.get(subpops[i]).species.newIndividual( state, dataIn );</span>
<span class="nc" id="L783">                updateFitness[i] = dataIn.readBoolean();</span>
                }
            }
<span class="nc" id="L786">        catch (Exception e)</span>
            {
<span class="nc" id="L788">            state.output.fatal(&quot;Unable to read individual from master:\n&quot; + e);</span>
<span class="nc" id="L789">            }</span>
                
        // Evaluate the individuals together
<span class="nc" id="L792">        ((GroupedProblemForm)(state.evaluator.p_problem)).evaluate( state, inds, updateFitness, countVictoriesOnly, subpops, 0 );</span>
                                
        try 
            {
<span class="nc" id="L796">            returnIndividualsToMaster(state, inds, updateFitness, dataOut, returnIndividuals, -1);      // -1 == write all individuals</span>
<span class="nc" id="L797">            dataOut.flush();</span>
            } 
<span class="nc" id="L799">        catch( IOException e ) { state.output.fatal(&quot;Caught fatal IOException\n&quot;+e ); }</span>
<span class="nc" id="L800">        }</span>
        
        
        
        
        
    // if individualInQuestion is -1, all individuals are returned
    static void returnIndividualsToMaster(EvolutionState state, Individual []inds, boolean[] updateFitness,
        DataOutputStream dataOut, boolean returnIndividuals, int individualInQuestion) throws IOException 
        {
        // Return the evaluated individual to the master
        // just write evaluated and fitness
<span class="nc bnc" id="L812" title="All 2 branches missed.">        int startInd = (individualInQuestion == -1 ? 0 : individualInQuestion);</span>
<span class="nc bnc" id="L813" title="All 2 branches missed.">        int endInd = (individualInQuestion == -1 ? inds.length : individualInQuestion + 1);</span>
<span class="nc bnc" id="L814" title="All 2 branches missed.">        for(int i = startInd; i&lt;endInd;i++)</span>
            {
<span class="nc bnc" id="L816" title="All 4 branches missed.">            dataOut.writeByte(returnIndividuals ? V_INDIVIDUAL : (updateFitness[i] ? V_FITNESS : V_NOTHING));</span>
<span class="nc bnc" id="L817" title="All 2 branches missed.">            if (returnIndividuals)</span>
                {
<span class="nc" id="L819">                inds[i].writeIndividual(state, dataOut);</span>
                }
<span class="nc bnc" id="L821" title="All 2 branches missed.">            else if (updateFitness[i])</span>
                {
<span class="nc" id="L823">                dataOut.writeBoolean(inds[i].evaluated);</span>
<span class="nc" id="L824">                inds[i].fitness.writeFitness(state,dataOut);</span>
                }
            }
<span class="nc" id="L827">        }</span>
    }
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>