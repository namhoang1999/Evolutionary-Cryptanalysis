<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BBOBenchmarks.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">ecj</a> &gt; <a href="index.source.html" class="el_package">ec.app.bbob</a> &gt; <span class="el_source">BBOBenchmarks.java</span></div><h1>BBOBenchmarks.java</h1><pre class="source lang-java linenums">package ec.app.bbob;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;

import ec.*;
import ec.gp.koza.HalfBuilder;
import ec.simple.SimpleFitness;
import ec.simple.SimpleProblemForm;
import ec.util.MersenneTwisterFast;
import ec.util.Parameter;
import ec.util.QuickSort;
import ec.vector.DoubleVectorIndividual;
import ec.util.ParameterDatabase;
import ec.util.MersenneTwisterFast;

/* 
 * BBOBenchmarks.java
 * 
 * Created: Fri Apr 2 09:00:00 2010
 * By: Faisal Abidi
 */

/**
 * The Black Box Optimization workshop (BBOB) has an annual competition for doing real-valued parameter optimization.
 * The examples shown here are more or less faithful reproductions of the BBOB 2010 C code, only using Mersenne Twister
 * instead of BBOB's random number generator.  Unfortunately, the original BBOB code has various magic numbers, unexplained
 * variables, and unfortunate algorithmic decisions.  We've reproduced them exactly rather than attempt to convert to a 
 * standard ECJ template, and simply apologize beforehand.
 *
 * &lt;p&gt;
 * &lt;b&gt;Parameters&lt;/b&gt;&lt;br&gt;
 * &lt;table&gt;
 * &lt;tr&gt;
 * &lt;td valign=top&gt;&lt;i&gt;base&lt;/i&gt;.&lt;tt&gt;type&lt;/tt&gt;&lt;br&gt;
 * &lt;font size=-1&gt; String = &lt;tt&gt;none &lt;/tt&gt;(default)
 * &lt;tt&gt;, sphere, ellipsoidal, rastrigin, buch-rastrigin, linear-slope, attractive-sector, step-elipsoidal, rosenbrock, rosenbrock-rotated, ellipsoidal-2, discus, bent-cigar, sharp-ridge, different-powers, rastrigin-2,
 * weierstrass, schaffers-f7, schaffers-f7-2, griewak-rosenbrock, schwefel, gallagher-gaussian-101me, gallagher-gaussian-21hi, katsuura, lunacek&lt;/tt&gt;
 * &lt;/font&gt;&lt;/td&gt;
 * &lt;td valign=top&gt;(The particular function)
 * &lt;tr&gt;
 * &lt;td valign=top&gt;&lt;i&gt;base&lt;/i&gt;.&lt;tt&gt;noise&lt;/tt&gt;&lt;br&gt;
 * &lt;font size=-1&gt; String = &lt;tt&gt;none &lt;/tt&gt;(default)
 * &lt;tt&gt;, gauss, uniform, cauchy, gauss-moderate, uniform-moderate, cauchy-moderate&lt;/tt&gt;
 * &lt;/font&gt;&lt;/td&gt;
 * &lt;td valign=top&gt;(what type of noise (if any) to add to the function value)
 * &lt;tr&gt;
 * &lt;td valign=top&gt;&lt;i&gt;base&lt;/i&gt;.&lt;tt&gt;reevaluate-noisy-problems&lt;/tt&gt;&lt;br&gt;
 * &lt;font size=-1&gt; boolean = &lt;tt&gt;true&lt;/tt&gt;(default)
 * &lt;/font&gt;&lt;/td&gt;
 * &lt;td valign=top&gt;(whether to reevaluate noisy problems)
 * &lt;/table&gt;
 * 
 * 
 * @author Faisal Abidi
 * @version 1.0
 */

<span class="fc" id="L61">public class BBOBenchmarks extends Problem implements SimpleProblemForm {</span>
    public static final String P_GENOME_SIZE = &quot;genome-size&quot;;
    public static final String P_WHICH_PROBLEM = &quot;type&quot;;
    public static final String P_NOISE = &quot;noise&quot;;
    public static final String P_REEVALUATE_NOISY_PROBLEMS = &quot;reevaluate-noisy-problems&quot;;
    public static final String P_ZERO_IS_BEST = &quot;zeroIsBest&quot;;
    public static final String P_XOPT = &quot;xopt&quot;;

<span class="fc" id="L69">    final public String[] problemTypes =</span>
        {&quot;sphere&quot;, &quot;ellipsoidal&quot;, &quot;rastrigin&quot;, &quot;buche-rastrigin&quot;, &quot;linear-slope&quot;, &quot;attractive-sector&quot;, &quot;step-ellipsoidal&quot;, &quot;rosenbrock&quot;, &quot;rosenbrock-rotated&quot;, &quot;ellipsoidal-2&quot;, &quot;discus&quot;, &quot;bent-cigar&quot;, &quot;sharp-ridge&quot;, &quot;different-powers&quot;, &quot;rastrigin-2&quot;,
         &quot;weierstrass&quot;, &quot;schaffers-f7&quot;, &quot;schaffers-f7-2&quot;, &quot;griewank-rosenbrock&quot;, &quot;schwefel&quot;, &quot;gallagher-gaussian-101me&quot;, &quot;gallagher-gaussian-21hi&quot;, &quot;katsuura&quot;, &quot;lunacek&quot;};

    final static public int SPHERE = 0;
    final static public int ELLIPSOIDAL = 1;
    final static public int RASTRIGIN = 2;
    final static public int BUCHE_RASTRIGIN = 3;
    final static public int LINEAR_SLOPE = 4;
    final static public int ATTRACTIVE_SECTOR = 5;
    final static public int STEP_ELLIPSOIDAL = 6;
    final static public int ROSENBROCK = 7;
    final static public int ROSENBROCK_ROTATED = 8;
    final static public int ELLIPSOIDAL_2 = 9;
    final static public int DISCUS = 10;
    final static public int BENT_CIGAR = 11;
    final static public int SHARP_RIDGE = 12;
    final static public int DIFFERENT_POWERS = 13;
    final static public int RASTRIGIN_2 = 14;
    final static public int WEIERSTRASS = 15;
    final static public int SCHAFFERS_F7 = 16;
    final static public int SCHAFFERS_F7_2 = 17;
    final static public int GRIEWANK_ROSENBROCK = 18;
    final static public int SCHWEFEL = 19;
    final static public int GALLAGHER_GAUSSIAN_101ME = 20;
    final static public int GALLAGHER_GAUSSIAN_21HI = 21;
    final static public int KATSUURA = 22;
    final static public int LUNACEK = 23;

    // Noise types
<span class="fc" id="L99">    final public String[] noiseTypes =</span>
        {&quot;none&quot;, &quot;gauss&quot;, &quot;uniform&quot;, &quot;cauchy&quot;, &quot;gauss-moderate&quot;, &quot;uniform-moderate&quot;, &quot;cauchy-moderate&quot;};

    final static public int NONE = 0;
    final static public int GAUSSIAN = 1;
    final static public int UNIFORM = 2;
    final static public int CAUCHY = 3;
    final static public int GAUSSIAN_MODERATE = 4;
    final static public int UNIFORM_MODERATE = 5;
    final static public int CAUCHY_MODERATE = 6;

<span class="fc" id="L110">    public int problemType = 0; // defaults on SPHERE</span>

<span class="fc" id="L112">    public int noise = NONE; // defaults to NONE</span>

    public boolean reevaluateNoisyProblems;
    public boolean zeroIsBest;

    public static final int NHIGHPEAKS21 = 101;
    public static final int NHIGHPEAKS22 = 21;

    // DO NOT MODIFY THESE VARIABLES except in the setup method: global
    // variables are not threadsafe.
    double fOpt;
    double[] xOpt;
    double fAdd_Init;

    double f0;
    double[][] rotation;
    double[][] rot2;
    double[][] linearTF;
    double[] peaks21;
    double[] peaks22;
    int[] rperm;
    int[] rperm21;
    int[] rperm22;
    double[][] xLocal;
    double[][] xLocal21;
    double[][] xLocal22;
    double[][] arrScales;
    double[][] arrScales21;
    double[][] arrScales22;
    double[] aK;
    double[] bK;
    double[] peakvalues;
    double scales;

    public static void main(String[] args) {
        //csv will have x, y and eval columns
<span class="nc" id="L148">        final Parameter BASE = new Parameter(&quot;base&quot;);</span>
        ParameterDatabase params;
<span class="nc" id="L150">        params = new ParameterDatabase();</span>
        EvolutionState state;

<span class="nc" id="L153">        params.set(new Parameter(Initializer.P_POP).push(Population.P_SUBPOP).push(&quot;0&quot;).push(Subpopulation.P_SPECIES).push(BBOBenchmarks.P_GENOME_SIZE), &quot;2&quot;);</span>
<span class="nc" id="L154">        params.set(BASE.push(BBOBenchmarks.P_WHICH_PROBLEM), args[0]);</span>
<span class="nc" id="L155">        params.set(BASE.push(BBOBenchmarks.P_NOISE), &quot;none&quot;);</span>
<span class="nc" id="L156">        params.set(BASE.push(BBOBenchmarks.P_REEVALUATE_NOISY_PROBLEMS), &quot;true&quot;);</span>

<span class="nc" id="L158">        state = new EvolutionState();</span>
<span class="nc" id="L159">        state.parameters = params;</span>
<span class="nc" id="L160">        state.output = Evolve.buildOutput(true);</span>
<span class="nc" id="L161">        state.random = new MersenneTwisterFast[] { new MersenneTwisterFast() };</span>

<span class="nc" id="L163">        BBOBenchmarks instance = new BBOBenchmarks();</span>
<span class="nc" id="L164">        instance.setup(state, BASE);</span>

<span class="nc" id="L166">        int whichLog = state.output.numLogs() - 1;</span>
<span class="nc" id="L167">        File f = new File(&quot;bbob.csv&quot;);</span>
        try {
<span class="nc" id="L169">            whichLog = state.output.addLog(f, false);</span>
<span class="nc" id="L170">            } catch (IOException io) {</span>
<span class="nc" id="L171">            state.output.fatal(&quot;An IOException occurred while trying to create bbob.csv&quot;);</span>
<span class="nc" id="L172">            }</span>

<span class="nc" id="L174">        double granularity = Double.parseDouble(args[1]);</span>
<span class="nc" id="L175">        ArrayList&lt;Double&gt; possibleVals = new ArrayList&lt;Double&gt;();</span>
<span class="nc bnc" id="L176" title="All 2 branches missed.">        for(double i =-10;i&lt;10;i+=granularity){</span>
<span class="nc" id="L177">            possibleVals.add(i);</span>
            }
<span class="nc" id="L179">        int valsLength = possibleVals.size();</span>
<span class="nc" id="L180">        ArrayList&lt;Double[]&gt; XYPair = new ArrayList&lt;Double[]&gt;();</span>
<span class="nc bnc" id="L181" title="All 2 branches missed.">        for(int i=0;i&lt;valsLength;i++){</span>
<span class="nc bnc" id="L182" title="All 2 branches missed.">            for(int j=0;j&lt;valsLength;j++){</span>
<span class="nc" id="L183">                Double[] temp = new Double[]{possibleVals.get(i),possibleVals.get(j)};</span>
<span class="nc" id="L184">                XYPair.add(temp);</span>
                }
            }
<span class="nc" id="L187">        int pairNumber = XYPair.size();</span>
<span class="nc" id="L188">        DoubleVectorIndividual[] inds = new DoubleVectorIndividual[pairNumber];</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">        for(int i=0;i&lt;pairNumber;i++){</span>
<span class="nc" id="L190">            Double[] pair = XYPair.get(i);</span>
<span class="nc" id="L191">            inds[i] = new DoubleVectorIndividual();</span>
<span class="nc" id="L192">            inds[i].setGenome(new double[]{pair[0],pair[1]});</span>
<span class="nc" id="L193">            inds[i].fitness = new SimpleFitness();</span>
<span class="nc" id="L194">            instance.evaluate(state,inds[i],0,0);</span>
<span class="nc" id="L195">            state.output.println(pair[0]+&quot;, &quot;+pair[1] +&quot;, &quot;+inds[i].fitness.fitnessToStringForHumans().split(&quot; &quot;)[1],whichLog);</span>
            }
<span class="nc" id="L197">        }                                                                                                                                                            </span>

    public void setup(final EvolutionState state, final Parameter base) {
<span class="fc" id="L200">        super.setup(state, base);</span>
<span class="fc" id="L201">        String wp = state.parameters.getStringWithDefault(base.push(P_WHICH_PROBLEM), null, &quot;&quot;);</span>
        int i, j, k;
<span class="fc" id="L203">        Parameter p = new Parameter(Initializer.P_POP);</span>
<span class="fc" id="L204">        int genomeSize = state.parameters.getInt(p.push(Population.P_SUBPOP).push(&quot;0&quot;).push(Subpopulation.P_SPECIES).push(P_GENOME_SIZE), null, 1);</span>
<span class="fc" id="L205">        String noiseStr = state.parameters.getString(base.push(P_NOISE), null);</span>
<span class="fc bfc" id="L206" title="All 2 branches covered.">        for (i = 0; i &lt; noiseTypes.length; i++)</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">            if (noiseStr.equals(noiseTypes[i]))</span>
<span class="fc" id="L208">                noise = i;</span>

<span class="fc" id="L210">        reevaluateNoisyProblems = state.parameters.getBoolean(base.push(P_REEVALUATE_NOISY_PROBLEMS), null, true);</span>
<span class="fc" id="L211">        zeroIsBest = state.parameters.getBoolean(base.push(P_ZERO_IS_BEST), null, false);</span>

<span class="fc" id="L213">        double condition = 10.0;</span>
<span class="fc" id="L214">        double alpha = 100.0;</span>
        double tmp, tmp2, maxCondition;
<span class="fc" id="L216">        double[] fitValues = {1.1, 9.1};</span>

        double[] arrCondition, peaks, tmpvect;

<span class="fc bfc" id="L220" title="All 2 branches covered.">        for (i = 0; i &lt; problemTypes.length; i++)</span>
<span class="fc bfc" id="L221" title="All 2 branches covered.">            if (wp.equals(problemTypes[i]))</span>
<span class="fc" id="L222">                problemType = i;</span>

        // common Initialization
<span class="fc" id="L225">        double compF = computeFopt(state.random[0]);</span>
<span class="fc bfc" id="L226" title="All 2 branches covered.">        fOpt = zeroIsBest ? 0.0 : compF;</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">        if(!state.parameters.exists(base.push(P_XOPT),null)){</span>
<span class="fc" id="L228">            xOpt = new double[genomeSize];</span>
<span class="fc" id="L229">            computeXopt(xOpt, state.random[0]);</span>
            }else{
<span class="fc" id="L231">            xOpt = state.parameters.getDoublesWithMax(base.push(P_XOPT),null,-5,5,genomeSize);</span>
            }
<span class="fc" id="L233">        rotation = new double[genomeSize][genomeSize];</span>
<span class="fc" id="L234">        rot2 = new double[genomeSize][genomeSize];</span>
<span class="fc" id="L235">        linearTF = new double[genomeSize][genomeSize];</span>
<span class="fc" id="L236">        computeRotation(rotation, state.random[0], genomeSize);</span>
<span class="fc" id="L237">        computeRotation(rot2, state.random[0], genomeSize);</span>
<span class="fc" id="L238">        scales = Math.max(1.0, Math.sqrt(genomeSize) / 8.);</span>

<span class="pc bpc" id="L240" title="1 of 25 branches missed.">        switch (problemType) {</span>
        case SPHERE:
            /* INITIALIZATION */
<span class="fc" id="L243">            break;</span>

        case ELLIPSOIDAL: // f2
<span class="pc bpc" id="L246" title="1 of 2 branches missed.">            if (noise != NONE) {</span>
<span class="nc" id="L247">                rot2 = new double[genomeSize][genomeSize];</span>
<span class="nc" id="L248">                computeRotation(rot2, state.random[0], genomeSize);</span>
                }
            break;

        case RASTRIGIN:
<span class="fc" id="L253">            break;</span>

        case BUCHE_RASTRIGIN:
<span class="fc bfc" id="L256" title="All 2 branches covered.">            for (i = 0; i &lt; genomeSize; i += 2)</span>
<span class="fc" id="L257">                xOpt[i] = Math.abs(xOpt[i]); /* Skew */</span>
            break;

        case LINEAR_SLOPE:
<span class="fc bfc" id="L261" title="All 2 branches covered.">            for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc" id="L262">                tmp = Math.pow(Math.sqrt(alpha), ((double) i) / ((double) (genomeSize - 1)));</span>
<span class="pc bpc" id="L263" title="1 of 2 branches missed.">                if (xOpt[i] &gt; 0) {</span>
<span class="fc" id="L264">                    xOpt[i] = 5.;</span>
<span class="nc bnc" id="L265" title="All 2 branches missed.">                    } else if (xOpt[i] &lt;= 0) {</span>
<span class="nc" id="L266">                    xOpt[i] = -5.;</span>
                    }
<span class="fc" id="L268">                fAdd_Init += 5. * tmp;</span>
                }
            break;

        case ATTRACTIVE_SECTOR:
            /* decouple scaling from function definition */
<span class="fc bfc" id="L274" title="All 2 branches covered.">            for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc bfc" id="L275" title="All 2 branches covered.">                for (j = 0; j &lt; genomeSize; j++) {</span>
<span class="fc" id="L276">                    linearTF[i][j] = 0.0;</span>
<span class="fc bfc" id="L277" title="All 2 branches covered.">                    for (k = 0; k &lt; genomeSize; k++) {</span>
<span class="fc" id="L278">                        linearTF[i][j] += rotation[i][k] * Math.pow(Math.sqrt(condition), ((double) k) / ((double) (genomeSize - 1))) * rot2[k][j];</span>
                        }
                    }
                }
            break;

        case STEP_ELLIPSOIDAL:
<span class="fc" id="L285">            break;</span>

        case ROSENBROCK:
<span class="pc bpc" id="L288" title="1 of 2 branches missed.">            if (noise == NONE)</span>
<span class="fc bfc" id="L289" title="All 2 branches covered.">                for (i = 0; i &lt; genomeSize; i++)</span>
<span class="fc" id="L290">                    xOpt[i] *= 0.75;</span>
            break;

        case ROSENBROCK_ROTATED:
            /* INITIALIZATION */
            /* computeXopt(state.random[0], genomeSize); */
<span class="fc bfc" id="L296" title="All 2 branches covered.">            for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc bfc" id="L297" title="All 2 branches covered.">                for (j = 0; j &lt; genomeSize; j++)</span>
<span class="fc" id="L298">                    linearTF[i][j] = scales * rotation[i][j];</span>
                }
            break;

        case ELLIPSOIDAL_2:
            ;
<span class="fc" id="L304">            break;</span>

        case DISCUS:
<span class="fc" id="L307">            break;</span>

        case BENT_CIGAR:
<span class="fc" id="L310">            break;</span>

        case SHARP_RIDGE:
<span class="fc bfc" id="L313" title="All 2 branches covered.">            for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc bfc" id="L314" title="All 2 branches covered.">                for (j = 0; j &lt; genomeSize; j++) {</span>
<span class="fc" id="L315">                    linearTF[i][j] = 0.0;</span>
<span class="fc bfc" id="L316" title="All 2 branches covered.">                    for (k = 0; k &lt; genomeSize; k++) {</span>
<span class="fc" id="L317">                        linearTF[i][j] += rotation[i][k] * Math.pow(Math.sqrt(condition), ((double) k) / ((double) (genomeSize - 1))) * rot2[k][j];</span>
                        }
                    }
                }
            break;

        case DIFFERENT_POWERS:
<span class="fc" id="L324">            break;</span>

        case RASTRIGIN_2:
<span class="fc bfc" id="L327" title="All 2 branches covered.">            for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc bfc" id="L328" title="All 2 branches covered.">                for (j = 0; j &lt; genomeSize; j++) {</span>
<span class="fc" id="L329">                    linearTF[i][j] = 0.0;</span>
<span class="fc bfc" id="L330" title="All 2 branches covered.">                    for (k = 0; k &lt; genomeSize; k++) {</span>
<span class="fc" id="L331">                        linearTF[i][j] += rotation[i][k] * Math.pow(Math.sqrt(condition), ((double) k) / ((double) (genomeSize - 1))) * rot2[k][j];</span>
                        }
                    }
                }
            break;

        case WEIERSTRASS:
<span class="fc" id="L338">            aK = new double[12];</span>
<span class="fc" id="L339">            bK = new double[12];</span>

<span class="fc bfc" id="L341" title="All 2 branches covered.">            for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc bfc" id="L342" title="All 2 branches covered.">                for (j = 0; j &lt; genomeSize; j++) {</span>
<span class="fc" id="L343">                    linearTF[i][j] = 0.0;</span>
<span class="fc bfc" id="L344" title="All 2 branches covered.">                    for (k = 0; k &lt; genomeSize; k++) {</span>
<span class="fc" id="L345">                        linearTF[i][j] += rotation[i][k] * Math.pow(1.0 / Math.sqrt(condition), ((double) k) / ((double) (genomeSize - 1))) * rot2[k][j];</span>
                        }
                    }
                }

<span class="fc" id="L350">            f0 = 0.0;</span>
<span class="fc bfc" id="L351" title="All 2 branches covered.">            for (i = 0; i &lt; 12; i++) /*</span>
                                      * number of summands, 20 in CEC2005, 10/12
                                      * saves 30% of time
                                      */ {
<span class="fc" id="L355">                aK[i] = Math.pow(0.5, (double) i);</span>
<span class="fc" id="L356">                bK[i] = Math.pow(3., (double) i);</span>
<span class="fc" id="L357">                f0 += aK[i] * Math.cos(2 * Math.PI * bK[i] * 0.5);</span>
                }
            break;

        case SCHAFFERS_F7:
<span class="fc" id="L362">            break;</span>

        case SCHAFFERS_F7_2:
<span class="fc" id="L365">            break;</span>

        case GRIEWANK_ROSENBROCK:
<span class="pc bpc" id="L368" title="1 of 2 branches missed.">            if (noise == NONE) {</span>
<span class="fc" id="L369">                rot2 = new double[genomeSize][genomeSize];</span>
<span class="fc" id="L370">                linearTF = new double[genomeSize][genomeSize];</span>
<span class="fc bfc" id="L371" title="All 2 branches covered.">                for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc bfc" id="L372" title="All 2 branches covered.">                    for (j = 0; j &lt; genomeSize; j++) {</span>
<span class="fc" id="L373">                        linearTF[i][j] = scales * rotation[i][j];</span>
                        }
                    }
<span class="fc bfc" id="L376" title="All 2 branches covered.">                for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc" id="L377">                    xOpt[i] = 0.0;</span>
<span class="fc bfc" id="L378" title="All 2 branches covered.">                    for (j = 0; j &lt; genomeSize; j++) {</span>
<span class="fc" id="L379">                        xOpt[i] += linearTF[j][i] * 0.5 / scales / scales;</span>
                        }
                    }
                } else {
                // TODO
                }
            break;

        case SCHWEFEL:
            /* INITIALIZATION */
<span class="fc" id="L389">            tmpvect = new double[genomeSize];</span>

<span class="fc bfc" id="L391" title="All 2 branches covered.">            for (i = 0; i &lt; genomeSize; i++)</span>
<span class="fc" id="L392">                tmpvect[i] = nextDoubleClosedInterval(state.random[0]);</span>
<span class="fc bfc" id="L393" title="All 2 branches covered.">            for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc" id="L394">                xOpt[i] = 0.5 * 4.2096874633;</span>
<span class="fc bfc" id="L395" title="All 2 branches covered.">                if (tmpvect[i] - 0.5 &lt; 0)</span>
<span class="fc" id="L396">                    xOpt[i] *= -1.;</span>
                }
            break;

        case GALLAGHER_GAUSSIAN_101ME:
<span class="fc" id="L401">            maxCondition = 1000.0;</span>
<span class="fc" id="L402">            arrCondition = new double[NHIGHPEAKS21];</span>
<span class="fc" id="L403">            peaks21 = new double[genomeSize * NHIGHPEAKS21];</span>
<span class="fc" id="L404">            rperm21 = new int[Math.max(genomeSize, NHIGHPEAKS21)];</span>
<span class="fc" id="L405">            peaks = peaks21;</span>
<span class="fc" id="L406">            peakvalues = new double[NHIGHPEAKS21];</span>
<span class="fc" id="L407">            arrScales21 = new double[NHIGHPEAKS21][genomeSize];</span>
<span class="fc" id="L408">            xLocal21 = new double[genomeSize][NHIGHPEAKS21];</span>

<span class="fc bfc" id="L410" title="All 2 branches covered.">            for (i = 0; i &lt; NHIGHPEAKS21 - 1; i++)</span>
<span class="fc" id="L411">                peaks[i] = nextDoubleClosedInterval(state.random[0]);</span>
<span class="fc" id="L412">            rperm = rperm21;</span>
<span class="fc bfc" id="L413" title="All 2 branches covered.">            for (i = 0; i &lt; NHIGHPEAKS21 - 1; i++)</span>
<span class="fc" id="L414">                rperm[i] = i;</span>
<span class="fc" id="L415">            QuickSort.qsort(rperm);</span>

            /* Random permutation */

<span class="fc" id="L419">            arrCondition[0] = Math.sqrt(maxCondition);</span>
<span class="fc" id="L420">            peakvalues[0] = 10;</span>
<span class="fc bfc" id="L421" title="All 2 branches covered.">            for (i = 1; i &lt; NHIGHPEAKS21; i++) {</span>
<span class="fc" id="L422">                arrCondition[i] = Math.pow(maxCondition, (double) (rperm[i - 1]) / ((double) (NHIGHPEAKS21 - 2)));</span>
<span class="fc" id="L423">                peakvalues[i] = (double) (i - 1) / (double) (NHIGHPEAKS21 - 2) * (fitValues[1] - fitValues[0]) + fitValues[0];</span>
                }
<span class="fc" id="L425">            arrScales = arrScales21;</span>
<span class="fc bfc" id="L426" title="All 2 branches covered.">            for (i = 0; i &lt; NHIGHPEAKS21; i++) {</span>
<span class="fc bfc" id="L427" title="All 2 branches covered.">                for (j = 0; j &lt; genomeSize; j++)</span>
<span class="fc" id="L428">                    peaks[j] = nextDoubleClosedInterval(state.random[0]);</span>
<span class="fc bfc" id="L429" title="All 2 branches covered.">                for (j = 0; j &lt; genomeSize; j++)</span>
<span class="fc" id="L430">                    rperm[j] = j;</span>
                // qsort(rperm, genomeSize, sizeof(int), compare_doubles);
<span class="fc" id="L432">                QuickSort.qsort(rperm);</span>
<span class="fc bfc" id="L433" title="All 2 branches covered.">                for (j = 0; j &lt; genomeSize; j++) {</span>
<span class="fc" id="L434">                    arrScales[i][j] = Math.pow(arrCondition[i], ((double) rperm[j]) / ((double) (genomeSize - 1)) - 0.5);</span>
                    }
                }

<span class="fc bfc" id="L438" title="All 2 branches covered.">            for (i = 0; i &lt; genomeSize * NHIGHPEAKS21; i++)</span>
<span class="fc" id="L439">                peaks[i] = nextDoubleClosedInterval(state.random[0]);</span>
<span class="fc" id="L440">            xLocal = xLocal21;</span>
<span class="fc bfc" id="L441" title="All 2 branches covered.">            for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc" id="L442">                xOpt[i] = 0.8 * (10. * peaks[i] - 5.);</span>
<span class="fc bfc" id="L443" title="All 2 branches covered.">                for (j = 0; j &lt; NHIGHPEAKS21; j++) {</span>
<span class="fc" id="L444">                    xLocal[i][j] = 0.0;</span>
<span class="fc bfc" id="L445" title="All 2 branches covered.">                    for (k = 0; k &lt; genomeSize; k++) {</span>
<span class="fc" id="L446">                        xLocal[i][j] += rotation[i][k] * (10. * peaks[j * genomeSize + k] - 5.);</span>
                        }
<span class="fc bfc" id="L448" title="All 2 branches covered.">                    if (j == 0)</span>
<span class="fc" id="L449">                        xLocal[i][j] *= 0.8;</span>
                    }
                }
            break;

        case GALLAGHER_GAUSSIAN_21HI:
<span class="fc" id="L455">            maxCondition = 1000.0;</span>
<span class="fc" id="L456">            arrCondition = new double[NHIGHPEAKS22];</span>
<span class="fc" id="L457">            peaks22 = new double[genomeSize * NHIGHPEAKS22];</span>
<span class="fc" id="L458">            rperm22 = new int[Math.max(genomeSize, NHIGHPEAKS22)];</span>
<span class="fc" id="L459">            arrScales22 = new double[NHIGHPEAKS22][genomeSize];</span>
<span class="fc" id="L460">            xLocal22 = new double[genomeSize][NHIGHPEAKS22];</span>
<span class="fc" id="L461">            peaks = peaks22;</span>
<span class="fc" id="L462">            peakvalues = new double[NHIGHPEAKS22];</span>
<span class="fc" id="L463">            peaks = peaks22;</span>
<span class="fc bfc" id="L464" title="All 2 branches covered.">            for (i = 0; i &lt; NHIGHPEAKS22 - 1; i++)</span>
<span class="fc" id="L465">                peaks[i] = nextDoubleClosedInterval(state.random[0]);</span>
<span class="fc" id="L466">            rperm = rperm22;</span>
<span class="fc bfc" id="L467" title="All 2 branches covered.">            for (i = 0; i &lt; NHIGHPEAKS22 - 1; i++)</span>
<span class="fc" id="L468">                rperm[i] = i;</span>
            // NOTE: confirm if this is a valid java conversion.
<span class="fc" id="L470">            QuickSort.qsort(rperm);</span>
            /* Random permutation */
<span class="fc" id="L472">            arrCondition[0] = maxCondition;</span>
<span class="fc" id="L473">            peakvalues[0] = 10;</span>
<span class="fc bfc" id="L474" title="All 2 branches covered.">            for (i = 1; i &lt; NHIGHPEAKS22; i++) {</span>
<span class="fc" id="L475">                arrCondition[i] = Math.pow(maxCondition, (double) (rperm[i - 1]) / ((double) (NHIGHPEAKS22 - 2)));</span>
<span class="fc" id="L476">                peakvalues[i] = (double) (i - 1) / (double) (NHIGHPEAKS22 - 2) * (fitValues[1] - fitValues[0]) + fitValues[0];</span>
                }
<span class="fc" id="L478">            arrScales = arrScales22;</span>
<span class="fc bfc" id="L479" title="All 2 branches covered.">            for (i = 0; i &lt; NHIGHPEAKS22; i++) {</span>
<span class="fc bfc" id="L480" title="All 2 branches covered.">                for (j = 0; j &lt; genomeSize; j++)</span>
<span class="fc" id="L481">                    peaks[j] = nextDoubleClosedInterval(state.random[0]);</span>
<span class="fc bfc" id="L482" title="All 2 branches covered.">                for (j = 0; j &lt; genomeSize; j++)</span>
<span class="fc" id="L483">                    rperm[j] = j;</span>
                // qsort(rperm, genomeSize, sizeof(int), compare_doubles);
                // NOTE: confirm if converted correctly
<span class="fc" id="L486">                QuickSort.qsort(rperm);</span>
<span class="fc bfc" id="L487" title="All 2 branches covered.">                for (j = 0; j &lt; genomeSize; j++) {</span>
<span class="fc" id="L488">                    arrScales[i][j] = Math.pow(arrCondition[i], ((double) rperm[j]) / ((double) (genomeSize - 1)) - 0.5);</span>
                    }
                }

<span class="fc bfc" id="L492" title="All 2 branches covered.">            for (i = 0; i &lt; genomeSize * NHIGHPEAKS22; i++)</span>
<span class="fc" id="L493">                peaks[i] = nextDoubleClosedInterval(state.random[0]);</span>
<span class="fc" id="L494">            xLocal = xLocal22;</span>
<span class="fc bfc" id="L495" title="All 2 branches covered.">            for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc" id="L496">                xOpt[i] = 0.8 * (9.8 * peaks[i] - 4.9);</span>
<span class="fc bfc" id="L497" title="All 2 branches covered.">                for (j = 0; j &lt; NHIGHPEAKS22; j++) {</span>
<span class="fc" id="L498">                    xLocal[i][j] = 0.0;</span>
<span class="fc bfc" id="L499" title="All 2 branches covered.">                    for (k = 0; k &lt; genomeSize; k++) {</span>
<span class="fc" id="L500">                        xLocal[i][j] += rotation[i][k] * (9.8 * peaks[j * genomeSize + k] - 4.9);</span>
                        }
<span class="fc bfc" id="L502" title="All 2 branches covered.">                    if (j == 0)</span>
<span class="fc" id="L503">                        xLocal[i][j] *= 0.8;</span>
                    }
                }
            break;

        case KATSUURA:
<span class="fc bfc" id="L509" title="All 2 branches covered.">            for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc bfc" id="L510" title="All 2 branches covered.">                for (j = 0; j &lt; genomeSize; j++) {</span>
<span class="fc" id="L511">                    linearTF[i][j] = 0.0;</span>
<span class="fc bfc" id="L512" title="All 2 branches covered.">                    for (k = 0; k &lt; genomeSize; k++) {</span>
<span class="fc" id="L513">                        linearTF[i][j] += rotation[i][k] * Math.pow(Math.sqrt(condition), ((double) k) / (double) (genomeSize - 1)) * rot2[k][j];</span>
                        }
                    }
                }
            break;

        case LUNACEK:
<span class="fc" id="L520">            tmpvect = new double[genomeSize];</span>
<span class="fc" id="L521">            double mu1 = 2.5;</span>
<span class="fc" id="L522">            gauss(tmpvect, state.random[0]);</span>
<span class="fc bfc" id="L523" title="All 2 branches covered.">            for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc" id="L524">                xOpt[i] = 0.5 * mu1;</span>
<span class="fc bfc" id="L525" title="All 2 branches covered.">                if (tmpvect[i] &lt; 0.)</span>
<span class="fc" id="L526">                    xOpt[i] *= -1.;</span>
                }

<span class="fc bfc" id="L529" title="All 2 branches covered.">            for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc bfc" id="L530" title="All 2 branches covered.">                for (j = 0; j &lt; genomeSize; j++) {</span>
<span class="fc" id="L531">                    linearTF[i][j] = 0.0;</span>
<span class="fc bfc" id="L532" title="All 2 branches covered.">                    for (k = 0; k &lt; genomeSize; k++) {</span>
<span class="fc" id="L533">                        linearTF[i][j] += rotation[i][k] * Math.pow(Math.sqrt(condition), ((double) k) / ((double) (genomeSize - 1))) * rot2[k][j];</span>
                        }
                    }
                }
            break;

        default:
<span class="nc" id="L540">            String outputStr = &quot;Invalid value for parameter, or parameter not found.\n&quot; + &quot;Acceptable values are:\n&quot;;</span>
<span class="nc bnc" id="L541" title="All 2 branches missed.">            for (i = 0; i &lt; problemTypes.length; i++)</span>
<span class="nc" id="L542">                outputStr += problemTypes[i] + &quot;\n&quot;;</span>
<span class="nc" id="L543">            state.output.fatal(outputStr, base.push(P_WHICH_PROBLEM));</span>
            }

<span class="fc" id="L546">        }</span>

    public void evaluate(EvolutionState state, Individual ind, int subpopulation, int threadnum) {
<span class="pc bpc" id="L549" title="1 of 2 branches missed.">        if (noise != NONE) {</span>
<span class="nc bnc" id="L550" title="All 4 branches missed.">            if (!reevaluateNoisyProblems &amp;&amp; ind.evaluated) // don't bother reevaluating</span>
<span class="nc" id="L551">                return;</span>
<span class="pc bpc" id="L552" title="1 of 2 branches missed.">            } else if (ind.evaluated)  // don't bother reevaluating</span>
<span class="nc" id="L553">            return;</span>

<span class="pc bpc" id="L555" title="1 of 2 branches missed.">        if (!(ind instanceof DoubleVectorIndividual))</span>
<span class="nc" id="L556">            state.output.fatal(&quot;The individuals for this problem should be DoubleVectorIndividuals.&quot;);</span>
<span class="fc" id="L557">        DoubleVectorIndividual temp = (DoubleVectorIndividual) ind;</span>
<span class="fc" id="L558">        double[] genome = temp.genome;</span>
<span class="fc" id="L559">        int genomeSize = genome.length;</span>
<span class="fc" id="L560">        double value = 0;</span>
<span class="fc" id="L561">        double fit = 0;</span>
        int i, j;
<span class="fc" id="L563">        double condition = 0.0, alpha, beta, tmp = 0.0, tmp2 = 0.0, fAdd = 0, fPen = 0.0, x1 = 0.0, fac, a, f = 0.0, f2 = 0.0;</span>
<span class="fc" id="L564">        double[] tmx = new double[genomeSize];</span>
<span class="fc" id="L565">        double[] tmpvect = new double[genomeSize];</span>

<span class="pc bpc" id="L567" title="1 of 25 branches missed.">        switch (problemType) {</span>
        case SPHERE:// f1
            /* Sphere function */
<span class="fc" id="L570">            sphere(fAdd, genomeSize, genome, tmp, fPen, value, fit, ind, state, threadnum);</span>

<span class="fc" id="L572">            break;</span>

        case ELLIPSOIDAL:// f2
            /*
             * separable ellipsoid with monotone transformation with noiseless
             * condition 1e6 and noisy condition 1e4
             */
<span class="fc" id="L579">            ellipsoidal(fAdd, condition, tmx, genomeSize, genome, tmp, fPen, value, fit, ind, state, threadnum);</span>
<span class="fc" id="L580">            break;</span>

        case RASTRIGIN:// f3
            /* Rastrigin with monotone transformation separable &quot;condition&quot; 10 */
<span class="fc" id="L584">            rastrigin(fAdd, genomeSize, genome, tmp, tmp2, tmx, value, fit, ind, state, threadnum);</span>
<span class="fc" id="L585">            break;</span>

        case BUCHE_RASTRIGIN:// f4
            /* skew Rastrigin-Bueche, condition 10, skew-&quot;condition&quot; 100 */
<span class="fc" id="L589">            buche_rastrigin(fAdd, genomeSize, genome, tmp, tmp2, tmx, value, fit, ind, state, threadnum);</span>
<span class="fc" id="L590">            break;</span>

        case LINEAR_SLOPE:// f5
            /* linear slope */
<span class="fc" id="L594">            linear_slope(fAdd, genomeSize, genome, tmx, value, fit, ind, state, threadnum);</span>
<span class="fc" id="L595">            break;</span>

        case ATTRACTIVE_SECTOR:// f6
            /* attractive sector function */
<span class="fc" id="L599">            attractive_sector(fAdd, genomeSize, genome, tmx, value, fit, ind, state, threadnum);</span>
<span class="fc" id="L600">            break;</span>

        case STEP_ELLIPSOIDAL:// f7
            /* step-ellipsoid, condition 100 */
<span class="fc" id="L604">            step_ellipsoidal(fAdd, genomeSize, genome, tmp, tmx, tmpvect, x1, fPen, value, fit, ind, state, threadnum);</span>
<span class="fc" id="L605">            break;</span>

        case ROSENBROCK:// f8
            /* Rosenbrock, non-rotated */
<span class="fc" id="L609">            rosenbrock(fAdd, genomeSize, genome, tmp, tmx, fPen, value, fit, ind, state, threadnum);</span>
<span class="fc" id="L610">            break;</span>

        case ROSENBROCK_ROTATED:// f9
            /* Rosenbrock, rotated */
<span class="fc" id="L614">            rosenbrock_rotated(fAdd, genomeSize, genome, tmp, tmx, fPen, value, fit, ind, state, threadnum);</span>
<span class="fc" id="L615">            break;</span>

        case ELLIPSOIDAL_2:// f10
            /* ellipsoid with monotone transformation, condition 1e6 */
<span class="fc" id="L619">            ellipsoidal_2(fAdd, genomeSize, genome, tmp, tmx, value, fit, ind, state, threadnum);</span>
<span class="fc" id="L620">            break;</span>

        case DISCUS:// f11
            /* DISCUS (tablet) with monotone transformation, condition 1e6 */
<span class="fc" id="L624">            discus(fAdd, genomeSize, genome, tmx, value, fit, ind, state, threadnum);</span>
<span class="fc" id="L625">            break;</span>

        case BENT_CIGAR:// f12
            /* bent cigar with asymmetric space distortion, condition 1e6 */
<span class="fc" id="L629">            bent_cigar(fAdd, genomeSize, genome, tmx, tmpvect, value, fit, ind, state, threadnum);</span>
<span class="fc" id="L630">            break;</span>

        case SHARP_RIDGE:// f13
            /* sharp ridge */
<span class="fc" id="L634">            sharp_ridge(fAdd, genomeSize, genome, tmx, value, fit, ind, state, threadnum);</span>
<span class="fc" id="L635">            break;</span>


        case DIFFERENT_POWERS:// f14
            /* sum of different powers, between x^2 and x^6 */
<span class="fc" id="L640">            different_powers(fAdd, genomeSize, genome, tmp, tmx, fPen, value, fit, ind, state, threadnum);</span>
<span class="fc" id="L641">            break;</span>

        case RASTRIGIN_2:// f15
            /* Rastrigin with asymmetric non-linear distortion, &quot;condition&quot; 10 */
<span class="fc" id="L645">            rastrigin_2(fAdd, genomeSize, genome, tmp, tmp2, tmx, tmpvect, fPen, value, fit, ind, state, threadnum);</span>
<span class="fc" id="L646">            break;</span>

        case WEIERSTRASS:// f16
            /* Weierstrass, condition 100 */
<span class="fc" id="L650">            weierstrass(fAdd, genomeSize, genome, tmp, tmx, tmpvect, fPen, value, fit, ind, state, threadnum);</span>
<span class="fc" id="L651">            break;</span>

        case SCHAFFERS_F7:// f17
            /*
             * Schaffers F7 with asymmetric non-linear transformation, condition
             * 10
             */
<span class="fc" id="L658">            schaffersF7(fAdd, genomeSize, genome, tmp, tmx, tmpvect, fPen, value, fit, ind, state, threadnum);</span>
<span class="fc" id="L659">            break;</span>

        case SCHAFFERS_F7_2:// f18
            /*
             * Schaffers F7 with asymmetric non-linear transformation, condition
             * 1000
             */
<span class="fc" id="L666">            schaffersF72(fAdd, genomeSize, genome, tmp, tmx, tmpvect, fPen, value, fit, ind, state, threadnum);</span>
<span class="fc" id="L667">            break;</span>

        case GRIEWANK_ROSENBROCK:// f19
            /* F8f2 sum of Griewank-Rosenbrock 2-D blocks */
<span class="fc" id="L671">            griewank_rosenbrock(fAdd, genomeSize, genome, tmp, tmx, tmp2, f2, fPen, value, fit, ind, state, threadnum);</span>
<span class="fc" id="L672">            break;</span>


        case SCHWEFEL:// f20
            /* Schwefel with tridiagonal variable transformation */
<span class="fc" id="L677">            schwefel(fAdd, genomeSize, genome, tmp, tmx, tmpvect, fPen, value, fit, ind, state, threadnum);</span>
<span class="fc" id="L678">            break;</span>

        case GALLAGHER_GAUSSIAN_101ME:// f21
            /*
             * Gallagher with 101 Gaussian peaks, condition up to 1000, one
             * global rotation
             */
<span class="fc" id="L685">            gallagher_gaussian_101me(fAdd, genomeSize, genome, tmp, tmx, tmp2, f, fPen, value, fit, ind, state, threadnum);</span>
<span class="fc" id="L686">            break;</span>

        case GALLAGHER_GAUSSIAN_21HI:// f22
            /*
             * Gallagher with 21 Gaussian peaks, condition up to 1000, one
             * global rotation
             */
<span class="fc" id="L693">            gallagher_gaussian_21hi(fAdd, genomeSize, genome, tmp, tmx, tmp2, fPen, value, fit, ind, state, threadnum);</span>
<span class="fc" id="L694">            break;</span>

        case KATSUURA:// f23
<span class="fc" id="L697">            katsuura(fAdd, genomeSize, genome, tmp, tmp2, tmx, tmpvect, fPen, value, fit, ind, state, threadnum);</span>
            /* Katsuura function */
<span class="fc" id="L699">            break;</span>

        case LUNACEK:// f24
<span class="fc" id="L702">            lunacek(fAdd, genomeSize, genome, tmp, tmp2, condition, tmx, fPen, value, fit, ind, state, threadnum);</span>
<span class="fc" id="L703">            break;</span>
        default:
            break;
            }

<span class="fc" id="L708">        ind.evaluated = true;</span>
<span class="fc" id="L709">        }</span>

    void sphere(double fAdd, int genomeSize, double[] genome, double tmp, double fPen, double value, double fit, Individual ind, EvolutionState state, int threadnum) {
<span class="fc" id="L712">        fAdd = fOpt;</span>
        int i, j;
<span class="pc bpc" id="L714" title="1 of 2 branches missed.">        if (noise != NONE) {</span>
<span class="nc bnc" id="L715" title="All 2 branches missed.">            for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="nc" id="L716">                tmp = Math.abs(genome[i]) - 5.;</span>
<span class="nc bnc" id="L717" title="All 2 branches missed.">                if (tmp &gt; 0.0) {</span>
<span class="nc" id="L718">                    fPen += tmp * tmp;</span>
                    }
                }
<span class="nc" id="L721">            fAdd += 100. * fPen;</span>
            }
        /* COMPUTATION core */
<span class="fc bfc" id="L724" title="All 2 branches covered.">        for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc" id="L725">            tmp = genome[i] - xOpt[i];</span>
<span class="fc" id="L726">            value += tmp * tmp;</span>
            }
<span class="pc bpc" id="L728" title="7 of 8 branches missed.">        switch (noise) {</span>
        case NONE:
<span class="fc" id="L730">            break;</span>
        case GAUSSIAN:
<span class="nc" id="L732">            value = fGauss(value, 1.0, state.random[threadnum]);</span>
<span class="nc" id="L733">            break;</span>
        case UNIFORM:
<span class="nc" id="L735">            value = fUniform(value, 0.49 + 1.0 / genomeSize, 1.0, state.random[threadnum]);</span>
<span class="nc" id="L736">            break;</span>
        case CAUCHY:
<span class="nc" id="L738">            value = fCauchy(value, 1.0, 0.2, state.random[threadnum]);</span>
<span class="nc" id="L739">            break;</span>
        case GAUSSIAN_MODERATE:
<span class="nc" id="L741">            value = fGauss(value, 0.01, state.random[threadnum]);</span>
<span class="nc" id="L742">            break;</span>
        case UNIFORM_MODERATE:
<span class="nc" id="L744">            value = fUniform(value, 0.01 * (0.49 + 1. / genomeSize), 0.01, state.random[threadnum]);</span>
<span class="nc" id="L745">            break;</span>
        case CAUCHY_MODERATE:
<span class="nc" id="L747">            value = fCauchy(value, 0.01, 0.05, state.random[threadnum]);</span>
<span class="nc" id="L748">            break;</span>
        default:
<span class="nc" id="L750">            String outputStr = &quot;Invalid value for parameter, or parameter not found.\n&quot; + &quot;Acceptable values are:\n&quot;;</span>
<span class="nc bnc" id="L751" title="All 2 branches missed.">            for (i = 0; i &lt; noiseTypes.length; i++)</span>
<span class="nc" id="L752">                outputStr += noiseTypes[i] + &quot;\n&quot;;</span>
<span class="nc" id="L753">            state.output.fatal(outputStr, new Parameter(P_NOISE));</span>
            break;
            }
<span class="fc" id="L756">        value += fAdd;</span>
<span class="fc" id="L757">        fit = (-value);</span>
<span class="pc bpc" id="L758" title="1 of 2 branches missed.">        ((SimpleFitness) (ind.fitness)).setFitness(state, fit, fit == 0.0);</span>
<span class="fc" id="L759">        }</span>

    void ellipsoidal(double fAdd, double condition, double[] tmx, int genomeSize, double[] genome, double tmp, double fPen, double value, double fit, Individual ind, EvolutionState state, int threadnum) {
        int i, j;
<span class="fc" id="L763">        fAdd = fOpt;</span>
<span class="pc bpc" id="L764" title="1 of 2 branches missed.">        if (noise == NONE) {</span>
<span class="fc" id="L765">            condition = 1e6;</span>
<span class="fc bfc" id="L766" title="All 2 branches covered.">            for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc" id="L767">                tmx[i] = genome[i] - xOpt[i];</span>
                }
            } else {
<span class="nc" id="L770">            condition = 1e4;</span>
<span class="nc" id="L771">            fAdd = fOpt;</span>

            /* BOUNDARY HANDLING */
<span class="nc bnc" id="L774" title="All 2 branches missed.">            for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="nc" id="L775">                tmp = Math.abs(genome[i]) - 5.;</span>
<span class="nc bnc" id="L776" title="All 2 branches missed.">                if (tmp &gt; 0.) {</span>
<span class="nc" id="L777">                    fPen += tmp * tmp;</span>
                    }
                }
<span class="nc" id="L780">            fAdd += 100. * fPen;</span>

            /* TRANSFORMATION IN SEARCH SPACE */
<span class="nc bnc" id="L783" title="All 2 branches missed.">            for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="nc" id="L784">                tmx[i] = 0.;</span>
<span class="nc bnc" id="L785" title="All 2 branches missed.">                for (j = 0; j &lt; genomeSize; j++) {</span>
<span class="nc" id="L786">                    tmx[i] += rotation[i][j] * (genome[j] - xOpt[j]);</span>
                    }
                }
            }

<span class="fc" id="L791">        monotoneTFosc(tmx);</span>
        /* COMPUTATION core */
<span class="fc bfc" id="L793" title="All 2 branches covered.">        for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc" id="L794">            value += Math.pow(condition, ((double) i) / ((double) (genomeSize - 1))) * tmx[i] * tmx[i];</span>
            }

<span class="pc bpc" id="L797" title="4 of 5 branches missed.">        switch (noise) {</span>
        case NONE:
<span class="fc" id="L799">            break;</span>
        case GAUSSIAN:
<span class="nc" id="L801">            value = fGauss(value, 1.0, state.random[threadnum]);</span>
<span class="nc" id="L802">            break;</span>
        case UNIFORM:
<span class="nc" id="L804">            value = fUniform(value, 0.49 + 1.0 / genomeSize, 1.0, state.random[threadnum]);</span>
<span class="nc" id="L805">            break;</span>
        case CAUCHY:
<span class="nc" id="L807">            value = fCauchy(value, 1.0, 0.2, state.random[threadnum]);</span>
<span class="nc" id="L808">            break;</span>
        default:
<span class="nc" id="L810">            String outputStr = &quot;Invalid value for parameter, or parameter not found.\n&quot; + &quot;Acceptable values are:\n&quot;;</span>
<span class="nc bnc" id="L811" title="All 2 branches missed.">            for (i = 0; i &lt; 4; i++)</span>
<span class="nc" id="L812">                outputStr += noiseTypes[i] + &quot;\n&quot;;</span>
<span class="nc" id="L813">            state.output.fatal(outputStr, new Parameter(P_NOISE));</span>
            break;
            }
<span class="fc" id="L816">        value += fAdd;</span>
<span class="fc" id="L817">        fit = (-value);</span>
<span class="pc bpc" id="L818" title="1 of 2 branches missed.">        ((SimpleFitness) (ind.fitness)).setFitness(state, fit, fit == 0.0);</span>
<span class="fc" id="L819">        }</span>

    void rastrigin(double fAdd, int genomeSize, double[] genome, double tmp, double tmp2, double[] tmx, double value, double fit, Individual ind, EvolutionState state, int threadnum) {
        int i;
<span class="fc" id="L823">        int condition = 10;</span>
<span class="fc" id="L824">        double beta = 0.2;</span>
<span class="fc" id="L825">        fAdd = fOpt;</span>
<span class="fc bfc" id="L826" title="All 2 branches covered.">        for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc" id="L827">            tmx[i] = genome[i] - xOpt[i];</span>
            }
<span class="fc" id="L829">        monotoneTFosc(tmx);</span>
<span class="fc bfc" id="L830" title="All 2 branches covered.">        for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc" id="L831">            tmp = ((double) i) / ((double) (genomeSize - 1));</span>
<span class="fc bfc" id="L832" title="All 2 branches covered.">            if (tmx[i] &gt; 0)</span>
<span class="fc" id="L833">                tmx[i] = Math.pow(tmx[i], 1 + beta * tmp * Math.sqrt(tmx[i]));</span>
<span class="fc" id="L834">            tmx[i] = Math.pow(Math.sqrt(condition), tmp) * tmx[i];</span>
            }
        /* COMPUTATION core */
<span class="fc" id="L837">        tmp = 0;</span>
<span class="fc" id="L838">        tmp2 = 0;</span>
<span class="fc bfc" id="L839" title="All 2 branches covered.">        for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc" id="L840">            tmp += Math.cos(2 * Math.PI * tmx[i]);</span>
<span class="fc" id="L841">            tmp2 += tmx[i] * tmx[i];</span>
            }
<span class="fc" id="L843">        value = 10 * (genomeSize - tmp) + tmp2;</span>
<span class="fc" id="L844">        value += fAdd;</span>

<span class="fc" id="L846">        fit = (-value);</span>
<span class="pc bpc" id="L847" title="1 of 2 branches missed.">        ((SimpleFitness) (ind.fitness)).setFitness(state, fit, fit == 0.0);</span>
<span class="fc" id="L848">        }</span>

    void buche_rastrigin(double fAdd, int genomeSize, double[] genome, double tmp, double tmp2, double[] tmx, double value, double fit, Individual ind, EvolutionState state, int threadnum) {
        int i;
<span class="fc" id="L852">        double condition = 10.0;</span>
<span class="fc" id="L853">        int alpha = 100;</span>
<span class="fc" id="L854">        fAdd = fOpt;</span>
<span class="fc" id="L855">        double fPen = 0.0;</span>
<span class="fc bfc" id="L856" title="All 2 branches covered.">        for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc" id="L857">            tmp = Math.abs(genome[i]) - 5.;</span>
<span class="pc bpc" id="L858" title="1 of 2 branches missed.">            if (tmp &gt; 0.)</span>
<span class="nc" id="L859">                fPen += tmp * tmp;</span>
            }
<span class="fc" id="L861">        fPen *= 1e2;</span>
<span class="fc" id="L862">        fAdd += fPen;</span>

<span class="fc bfc" id="L864" title="All 2 branches covered.">        for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc" id="L865">            tmx[i] = genome[i] - xOpt[i];</span>
            }

<span class="fc" id="L868">        monotoneTFosc(tmx);</span>
<span class="fc bfc" id="L869" title="All 2 branches covered.">        for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc bfc" id="L870" title="All 4 branches covered.">            if (i % 2 == 0 &amp;&amp; tmx[i] &gt; 0)</span>
<span class="fc" id="L871">                tmx[i] = Math.sqrt(alpha) * tmx[i];</span>
<span class="fc" id="L872">            tmx[i] = Math.pow(Math.sqrt(condition), ((double) i) / ((double) (genomeSize - 1))) * tmx[i];</span>
            }
        /* COMPUTATION core */
<span class="fc" id="L875">        tmp = 0.0;</span>
<span class="fc" id="L876">        tmp2 = 0.0;</span>
<span class="fc bfc" id="L877" title="All 2 branches covered.">        for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc" id="L878">            tmp += Math.cos(2 * Math.PI * tmx[i]);</span>
<span class="fc" id="L879">            tmp2 += tmx[i] * tmx[i];</span>
            }
<span class="fc" id="L881">        value = 10 * (genomeSize - tmp) + tmp2;</span>
<span class="fc" id="L882">        value += fAdd;</span>

<span class="fc" id="L884">        fit = (-value);</span>
<span class="pc bpc" id="L885" title="1 of 2 branches missed.">        ((SimpleFitness) (ind.fitness)).setFitness(state, fit, fit == 0.0);</span>
<span class="fc" id="L886">        }</span>

    void linear_slope(double fAdd, int genomeSize, double[] genome, double[] tmx, double value, double fit, Individual ind, EvolutionState state, int threadnum) {
        int i;
<span class="fc" id="L890">        int alpha = 100;</span>
<span class="fc" id="L891">        fAdd = fOpt;</span>
        /* BOUNDARY HANDLING */
        /* move &quot;too&quot; good coordinates back into domain */
<span class="fc bfc" id="L894" title="All 2 branches covered.">        for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="pc bpc" id="L895" title="2 of 4 branches missed.">            if ((xOpt[i] == 5.) &amp;&amp; (genome[i] &gt; 5))</span>
<span class="nc" id="L896">                tmx[i] = 5.;</span>
<span class="pc bpc" id="L897" title="3 of 4 branches missed.">            else if ((xOpt[i] == -5.) &amp;&amp; (genome[i] &lt; -5))</span>
<span class="nc" id="L898">                tmx[i] = -5.;</span>
            else
<span class="fc" id="L900">                tmx[i] = genome[i];</span>
            }

        /* COMPUTATION core */
<span class="fc" id="L904">        double base = Math.sqrt(alpha);</span>
<span class="fc" id="L905">        double exponent = ((double) i) / ((double) (genomeSize - 1));</span>
<span class="fc bfc" id="L906" title="All 2 branches covered.">        for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="pc bpc" id="L907" title="1 of 2 branches missed.">            if (xOpt[i] &gt; 0) {</span>
<span class="fc" id="L908">                value -= Math.pow(base, exponent) * tmx[i];</span>
                } else {
<span class="nc" id="L910">                value += Math.pow(base, exponent) * tmx[i];</span>
                }
            }
<span class="fc" id="L913">        value += fAdd;</span>

<span class="fc" id="L915">        fit = (-value);</span>
<span class="pc bpc" id="L916" title="1 of 2 branches missed.">        ((SimpleFitness) (ind.fitness)).setFitness(state, fit, fit == 0.0);</span>
<span class="fc" id="L917">        }</span>

    void attractive_sector(double fAdd, int genomeSize, double[] genome, double[] tmx, double value, double fit, Individual ind, EvolutionState state, int threadnum) {
        int i, j;
<span class="fc" id="L921">        double alpha = 100.0;</span>
<span class="fc" id="L922">        fAdd = fOpt;</span>

        /* BOUNDARY HANDLING */
        /* TRANSFORMATION IN SEARCH SPACE */
<span class="fc bfc" id="L926" title="All 2 branches covered.">        for (i = 0; i &lt; genomeSize; i++) {</span>

<span class="fc" id="L928">            tmx[i] = 0.0;</span>
<span class="fc bfc" id="L929" title="All 2 branches covered.">            for (j = 0; j &lt; genomeSize; j++) {</span>
<span class="fc" id="L930">                tmx[i] += linearTF[i][j] * (genome[j] - xOpt[j]);</span>
                }
            }

        /* COMPUTATION core */
<span class="fc bfc" id="L935" title="All 2 branches covered.">        for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc bfc" id="L936" title="All 2 branches covered.">            if (tmx[i] * xOpt[i] &gt; 0)</span>
<span class="fc" id="L937">                tmx[i] *= alpha;</span>
<span class="fc" id="L938">            value += tmx[i] * tmx[i];</span>
            }

        /* monotoneTFosc... */
<span class="pc bpc" id="L942" title="1 of 2 branches missed.">        if (value &gt; 0) {</span>
<span class="fc" id="L943">            value = Math.pow(Math.exp(Math.log(value) / 0.1 + 0.49 * (Math.sin(Math.log(value) / 0.1) + Math.sin(0.79 * Math.log(value) / 0.1))), 0.1);</span>
<span class="nc bnc" id="L944" title="All 2 branches missed.">            } else if (value &lt; 0) {</span>
<span class="nc" id="L945">            value = -Math.pow(Math.exp(Math.log(-value) / 0.1 + 0.49 * (Math.sin(0.55 * Math.log(-value) / 0.1) + Math.sin(0.31 * Math.log(-value) / 0.1))), 0.1);</span>
            }
<span class="fc" id="L947">        value = Math.pow(value, 0.9);</span>
<span class="fc" id="L948">        value += fAdd;</span>
<span class="fc" id="L949">        fit = (-value);</span>
<span class="pc bpc" id="L950" title="1 of 2 branches missed.">        ((SimpleFitness) (ind.fitness)).setFitness(state, fit, fit == 0.0);</span>
<span class="fc" id="L951">        }</span>

    void step_ellipsoidal(double fAdd, int genomeSize, double[] genome, double tmp, double[] tmx, double[] tmpvect, double x1, double fPen, double value, double fit, Individual ind, EvolutionState state, int threadnum) {
        int i, j;
<span class="fc" id="L955">        double condition = 100.0;</span>
<span class="fc" id="L956">        double alpha = 10.0;</span>
<span class="fc" id="L957">        fAdd = fOpt;</span>
        /* BOUNDARY HANDLING */
<span class="fc bfc" id="L959" title="All 2 branches covered.">        for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc" id="L960">            tmp = Math.abs(genome[i]) - 5.0;</span>
<span class="pc bpc" id="L961" title="1 of 2 branches missed.">            if (tmp &gt; 0.0) {</span>
<span class="nc" id="L962">                fPen += tmp * tmp;</span>
                }
            }
<span class="pc bpc" id="L965" title="1 of 2 branches missed.">        if (noise == NONE)</span>
<span class="fc" id="L966">            fAdd += fPen;</span>
        else
<span class="nc" id="L968">            fAdd += 100. * fPen;</span>

        /* TRANSFORMATION IN SEARCH SPACE */
<span class="fc bfc" id="L971" title="All 2 branches covered.">        for (i = 0; i &lt; genomeSize; i++) {</span>

<span class="fc" id="L973">            tmpvect[i] = 0.0;</span>
<span class="fc" id="L974">            tmp = Math.sqrt(Math.pow(condition / 10., ((double) i) / ((double) (genomeSize - 1))));</span>
<span class="fc bfc" id="L975" title="All 2 branches covered.">            for (j = 0; j &lt; genomeSize; j++) {</span>
<span class="fc" id="L976">                tmpvect[i] += tmp * rot2[i][j] * (genome[j] - xOpt[j]);</span>
                }

            }
<span class="fc" id="L980">        x1 = tmpvect[0];</span>

<span class="fc bfc" id="L982" title="All 2 branches covered.">        for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc bfc" id="L983" title="All 2 branches covered.">            if (Math.abs(tmpvect[i]) &gt; 0.5)</span>
<span class="fc" id="L984">                tmpvect[i] = Math.round(tmpvect[i]);</span>
            else
<span class="fc" id="L986">                tmpvect[i] = Math.round(alpha * tmpvect[i]) / alpha;</span>
            }

<span class="fc bfc" id="L989" title="All 2 branches covered.">        for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc" id="L990">            tmx[i] = 0.0;</span>
<span class="fc bfc" id="L991" title="All 2 branches covered.">            for (j = 0; j &lt; genomeSize; j++) {</span>
<span class="fc" id="L992">                tmx[i] += rotation[i][j] * tmpvect[j];</span>
                }
            }

        /* COMPUTATION core */
<span class="fc bfc" id="L997" title="All 2 branches covered.">        for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc" id="L998">            value += Math.pow(condition, ((double) i) / ((double) (genomeSize - 1))) * tmx[i] * tmx[i];</span>
            }
<span class="fc" id="L1000">        value = 0.1 * Math.max(1e-4 * Math.abs(x1), value);</span>
<span class="pc bpc" id="L1001" title="4 of 5 branches missed.">        switch (noise) {</span>
        case NONE:
<span class="fc" id="L1003">            break;</span>
        case GAUSSIAN:
<span class="nc" id="L1005">            value = fGauss(value, 1.0, state.random[threadnum]);</span>
<span class="nc" id="L1006">            break;</span>
        case UNIFORM:
<span class="nc" id="L1008">            value = fUniform(value, 0.49 + 1.0 / genomeSize, 1.0, state.random[threadnum]);</span>
<span class="nc" id="L1009">            break;</span>
        case CAUCHY:
<span class="nc" id="L1011">            value = fCauchy(value, 1.0, 0.2, state.random[threadnum]);</span>
<span class="nc" id="L1012">            break;</span>
        default:
<span class="nc" id="L1014">            String outputStr = &quot;Invalid value for parameter, or parameter not found.\n&quot; + &quot;Acceptable values are:\n&quot;;</span>
<span class="nc bnc" id="L1015" title="All 2 branches missed.">            for (i = 0; i &lt; 4; i++)</span>
<span class="nc" id="L1016">                outputStr += noiseTypes[i] + &quot;\n&quot;;</span>
<span class="nc" id="L1017">            state.output.fatal(outputStr, new Parameter(P_NOISE));</span>
            break;
            }
<span class="fc" id="L1020">        value += fAdd;</span>
<span class="fc" id="L1021">        fit = (-value);</span>
<span class="pc bpc" id="L1022" title="1 of 2 branches missed.">        ((SimpleFitness) (ind.fitness)).setFitness(state, fit, fit == 0.0);</span>
<span class="fc" id="L1023">        }</span>

    void rosenbrock(double fAdd, int genomeSize, double[] genome, double tmp, double[] tmx, double fPen, double value, double fit, Individual ind, EvolutionState state, int threadnum) {
        int i;
<span class="fc" id="L1027">        fAdd = fOpt;</span>
<span class="pc bpc" id="L1028" title="1 of 2 branches missed.">        if (noise == NONE) {</span>
            /* TRANSFORMATION IN SEARCH SPACE */
<span class="fc bfc" id="L1030" title="All 2 branches covered.">            for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc" id="L1031">                tmx[i] = scales * (genome[i] - xOpt[i]) + 1;</span>
                }
            } else {
            /* BOUNDARY HANDLING */
<span class="nc bnc" id="L1035" title="All 2 branches missed.">            for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="nc" id="L1036">                tmp = Math.abs(genome[i]) - 5.;</span>
<span class="nc bnc" id="L1037" title="All 2 branches missed.">                if (tmp &gt; 0.) {</span>
<span class="nc" id="L1038">                    fPen += tmp * tmp;</span>
                    }
                }
<span class="nc" id="L1041">            fAdd += 100.0 * fPen;</span>
            /* TRANSFORMATION IN SEARCH SPACE */
<span class="nc bnc" id="L1043" title="All 2 branches missed.">            for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="nc" id="L1044">                tmx[i] = scales * (genome[i] - 0.75 * xOpt[i]) + 1;</span>
                }
            }

        /* COMPUTATION core */
<span class="fc bfc" id="L1049" title="All 2 branches covered.">        for (i = 0; i &lt; genomeSize - 1; i++) {</span>
<span class="fc" id="L1050">            tmp = (tmx[i] * tmx[i] - tmx[i + 1]);</span>
<span class="fc" id="L1051">            value += tmp * tmp;</span>
            }
<span class="fc" id="L1053">        value *= 1e2;</span>
<span class="fc bfc" id="L1054" title="All 2 branches covered.">        for (i = 0; i &lt; genomeSize - 1; i++) {</span>
<span class="fc" id="L1055">            tmp = (tmx[i] - 1.);</span>
<span class="fc" id="L1056">            value += tmp * tmp;</span>
            }

<span class="pc bpc" id="L1059" title="7 of 8 branches missed.">        switch (noise) {</span>
        case NONE:
<span class="fc" id="L1061">            break;</span>
        case GAUSSIAN:
<span class="nc" id="L1063">            value = fGauss(value, 1.0, state.random[threadnum]);</span>
<span class="nc" id="L1064">            break;</span>
        case UNIFORM:
<span class="nc" id="L1066">            value = fUniform(value, 0.49 + 1.0 / genomeSize, 1.0, state.random[threadnum]);</span>
<span class="nc" id="L1067">            break;</span>
        case CAUCHY:
<span class="nc" id="L1069">            value = fCauchy(value, 1.0, 0.2, state.random[threadnum]);</span>
<span class="nc" id="L1070">            break;</span>
        case GAUSSIAN_MODERATE:
<span class="nc" id="L1072">            value = fGauss(value, 0.01, state.random[threadnum]);</span>
<span class="nc" id="L1073">            break;</span>
        case UNIFORM_MODERATE:
<span class="nc" id="L1075">            value = fUniform(value, 0.01 * (0.49 + 1. / genomeSize), 0.01, state.random[threadnum]);</span>
<span class="nc" id="L1076">            break;</span>
        case CAUCHY_MODERATE:
<span class="nc" id="L1078">            value = fCauchy(value, 0.01, 0.05, state.random[threadnum]);</span>
<span class="nc" id="L1079">            break;</span>
        default:
<span class="nc" id="L1081">            String outputStr = &quot;Invalid value for parameter, or parameter not found.\n&quot; + &quot;Acceptable values are:\n&quot;;</span>
<span class="nc bnc" id="L1082" title="All 2 branches missed.">            for (i = 0; i &lt; noiseTypes.length; i++)</span>
<span class="nc" id="L1083">                outputStr += noiseTypes[i] + &quot;\n&quot;;</span>
<span class="nc" id="L1084">            state.output.fatal(outputStr, new Parameter(P_NOISE));</span>
            break;
            }

<span class="fc" id="L1088">        value += fAdd;</span>

<span class="fc" id="L1090">        fit = (-value);</span>
<span class="pc bpc" id="L1091" title="1 of 2 branches missed.">        ((SimpleFitness) (ind.fitness)).setFitness(state, fit, fit == 0.0);</span>
<span class="fc" id="L1092">        }</span>

    void rosenbrock_rotated(double fAdd, int genomeSize, double[] genome, double tmp, double[] tmx, double fPen, double value, double fit, Individual ind, EvolutionState state, int threadnum) {
        int i, j;
<span class="fc" id="L1096">        fAdd = fOpt;</span>

        /* BOUNDARY HANDLING */

        /* TRANSFORMATION IN SEARCH SPACE */
<span class="fc bfc" id="L1101" title="All 2 branches covered.">        for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc" id="L1102">            tmx[i] = 0.5;</span>
<span class="fc bfc" id="L1103" title="All 2 branches covered.">            for (j = 0; j &lt; genomeSize; j++) {</span>
<span class="fc" id="L1104">                tmx[i] += linearTF[i][j] * genome[j];</span>
                }
            }

        /* COMPUTATION core */
<span class="fc bfc" id="L1109" title="All 2 branches covered.">        for (i = 0; i &lt; genomeSize - 1; i++) {</span>
<span class="fc" id="L1110">            tmp = (tmx[i] * tmx[i] - tmx[i + 1]);</span>
<span class="fc" id="L1111">            value += tmp * tmp;</span>
            }
<span class="fc" id="L1113">        value *= 1e2;</span>
<span class="fc bfc" id="L1114" title="All 2 branches covered.">        for (i = 0; i &lt; genomeSize - 1; i++) {</span>
<span class="fc" id="L1115">            tmp = (tmx[i] - 1.);</span>
<span class="fc" id="L1116">            value += tmp * tmp;</span>
            }

<span class="fc" id="L1119">        value += fAdd;</span>
<span class="fc" id="L1120">        fit = (-value);</span>
<span class="pc bpc" id="L1121" title="1 of 2 branches missed.">        ((SimpleFitness) (ind.fitness)).setFitness(state, fit, fit == 0.0);</span>
<span class="fc" id="L1122">        }</span>

    void schaffersF7(double fAdd, int genomeSize, double[] genome, double tmp, double[] tmx, double[] tmpvect, double fPen, double value, double fit, Individual ind, EvolutionState state, int threadnum) {
        int i, j;
<span class="fc" id="L1126">        double condition = 10.0;</span>
<span class="fc" id="L1127">        double beta = 0.5;</span>
<span class="fc" id="L1128">        fAdd = fOpt;</span>

        /* BOUNDARY HANDLING */
<span class="fc bfc" id="L1131" title="All 2 branches covered.">        for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc" id="L1132">            tmp = Math.abs(genome[i]) - 5.;</span>
<span class="pc bpc" id="L1133" title="1 of 2 branches missed.">            if (tmp &gt; 0.) {</span>
<span class="nc" id="L1134">                fPen += tmp * tmp;</span>
                }
            }
<span class="fc" id="L1137">        fAdd += 10. * fPen;</span>

        /* TRANSFORMATION IN SEARCH SPACE */
<span class="fc bfc" id="L1140" title="All 2 branches covered.">        for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc" id="L1141">            tmpvect[i] = 0.0;</span>
<span class="fc bfc" id="L1142" title="All 2 branches covered.">            for (j = 0; j &lt; genomeSize; j++) {</span>
<span class="fc" id="L1143">                tmpvect[i] += rotation[i][j] * (genome[j] - xOpt[j]);</span>
                }
<span class="fc bfc" id="L1145" title="All 2 branches covered.">            if (tmpvect[i] &gt; 0)</span>
<span class="fc" id="L1146">                tmpvect[i] = Math.pow(tmpvect[i], 1 + beta * ((double) i) / ((double) (genomeSize - 1)) * Math.sqrt(tmpvect[i]));</span>
            }

<span class="fc bfc" id="L1149" title="All 2 branches covered.">        for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc" id="L1150">            tmx[i] = 0.0;</span>
<span class="fc" id="L1151">            tmp = Math.pow(Math.sqrt(condition), ((double) i) / ((double) (genomeSize - 1)));</span>
<span class="fc bfc" id="L1152" title="All 2 branches covered.">            for (j = 0; j &lt; genomeSize; j++) {</span>
<span class="fc" id="L1153">                tmx[i] += tmp * rot2[i][j] * tmpvect[j];</span>
                }
            }

        /* COMPUTATION core */
<span class="fc bfc" id="L1158" title="All 2 branches covered.">        for (i = 0; i &lt; genomeSize - 1; i++) {</span>
<span class="fc" id="L1159">            tmp = tmx[i] * tmx[i] + tmx[i + 1] * tmx[i + 1];</span>
<span class="fc" id="L1160">            value += Math.pow(tmp, 0.25) * (Math.pow(Math.sin(50 * Math.pow(tmp, 0.1)), 2.0) + 1.0);</span>
            }
<span class="fc" id="L1162">        value = Math.pow(value / (double) (genomeSize - 1), 2.);</span>
<span class="pc bpc" id="L1163" title="4 of 5 branches missed.">        switch (noise) {</span>
        case NONE:
<span class="fc" id="L1165">            break;</span>
        case GAUSSIAN:
<span class="nc" id="L1167">            value = fGauss(value, 1.0, state.random[threadnum]);</span>
<span class="nc" id="L1168">            break;</span>
        case UNIFORM:
<span class="nc" id="L1170">            value = fUniform(value, 0.49 + 1.0 / genomeSize, 1.0, state.random[threadnum]);</span>
<span class="nc" id="L1171">            break;</span>
        case CAUCHY:
<span class="nc" id="L1173">            value = fCauchy(value, 1.0, 0.2, state.random[threadnum]);</span>
<span class="nc" id="L1174">            break;</span>
        default:
<span class="nc" id="L1176">            String outputStr = &quot;Invalid value for parameter, or parameter not found.\n&quot; + &quot;Acceptable values are:\n&quot;;</span>
<span class="nc bnc" id="L1177" title="All 2 branches missed.">            for (i = 0; i &lt; 4; i++)</span>
<span class="nc" id="L1178">                outputStr += noiseTypes[i] + &quot;\n&quot;;</span>
<span class="nc" id="L1179">            state.output.fatal(outputStr, new Parameter(P_NOISE));</span>
            break;
            }
<span class="fc" id="L1182">        value += fAdd;</span>
<span class="fc" id="L1183">        fit = (-value);</span>
<span class="pc bpc" id="L1184" title="1 of 2 branches missed.">        ((SimpleFitness) (ind.fitness)).setFitness(state, fit, fit == 0.0);</span>
<span class="fc" id="L1185">        }</span>

    void schaffersF72(double fAdd, int genomeSize, double[] genome, double tmp, double[] tmx, double[] tmpvect, double fPen, double value, double fit, Individual ind, EvolutionState state, int threadnum) {
        int i, j;
<span class="fc" id="L1189">        double condition = 1e3;</span>
<span class="fc" id="L1190">        double beta = 0.5;</span>
<span class="fc" id="L1191">        fPen = 0.0;</span>
<span class="fc" id="L1192">        fAdd = fOpt;</span>
        /* BOUNDARY HANDLING */
<span class="fc bfc" id="L1194" title="All 2 branches covered.">        for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc" id="L1195">            tmp = Math.abs(genome[i]) - 5.;</span>
<span class="pc bpc" id="L1196" title="1 of 2 branches missed.">            if (tmp &gt; 0.) {</span>
<span class="nc" id="L1197">                fPen += tmp * tmp;</span>
                }
            }
<span class="fc" id="L1200">        fAdd += 10. * fPen;</span>

        /* TRANSFORMATION IN SEARCH SPACE */
<span class="fc bfc" id="L1203" title="All 2 branches covered.">        for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc" id="L1204">            tmpvect[i] = 0.0;</span>
<span class="fc bfc" id="L1205" title="All 2 branches covered.">            for (j = 0; j &lt; genomeSize; j++) {</span>
<span class="fc" id="L1206">                tmpvect[i] += rotation[i][j] * (genome[j] - xOpt[j]);</span>
                }
<span class="fc bfc" id="L1208" title="All 2 branches covered.">            if (tmpvect[i] &gt; 0)</span>
<span class="fc" id="L1209">                tmpvect[i] = Math.pow(tmpvect[i], 1. + beta * ((double) i) / ((double) (genomeSize - 1)) * Math.sqrt(tmpvect[i]));</span>
            }

<span class="fc bfc" id="L1212" title="All 2 branches covered.">        for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc" id="L1213">            tmx[i] = 0.0;</span>
<span class="fc" id="L1214">            tmp = Math.pow(Math.sqrt(condition), ((double) i) / ((double) (genomeSize - 1)));</span>
<span class="fc bfc" id="L1215" title="All 2 branches covered.">            for (j = 0; j &lt; genomeSize; j++) {</span>
<span class="fc" id="L1216">                tmx[i] += tmp * rot2[i][j] * tmpvect[j];</span>
                }
            }

        /* COMPUTATION core */
<span class="fc bfc" id="L1221" title="All 2 branches covered.">        for (i = 0; i &lt; genomeSize - 1; i++) {</span>
<span class="fc" id="L1222">            tmp = tmx[i] * tmx[i] + tmx[i + 1] * tmx[i + 1];</span>
<span class="fc" id="L1223">            value += Math.pow(tmp, 0.25) * (Math.pow(Math.sin(50. * Math.pow(tmp, 0.1)), 2.) + 1.);</span>
            }
<span class="fc" id="L1225">        value = Math.pow(value / (double) (genomeSize - 1), 2.);</span>
<span class="fc" id="L1226">        value += fAdd;</span>
<span class="fc" id="L1227">        fit = (-value);</span>
<span class="pc bpc" id="L1228" title="1 of 2 branches missed.">        ((SimpleFitness) (ind.fitness)).setFitness(state, fit, fit == 0.0);</span>
<span class="fc" id="L1229">        }</span>

    void griewank_rosenbrock(double fAdd, int genomeSize, double[] genome, double tmp, double[] tmx, double tmp2, double f2, double fPen, double value, double fit, Individual ind, EvolutionState state, int threadnum) {
        int i, j;
<span class="fc" id="L1233">        fAdd = fOpt;</span>
<span class="pc bpc" id="L1234" title="1 of 2 branches missed.">        if (noise == NONE) {</span>
            /* TRANSFORMATION IN SEARCH SPACE */
<span class="fc bfc" id="L1236" title="All 2 branches covered.">            for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc" id="L1237">                tmx[i] = 0.5;</span>
<span class="fc bfc" id="L1238" title="All 2 branches covered.">                for (j = 0; j &lt; genomeSize; j++) {</span>
<span class="fc" id="L1239">                    tmx[i] += linearTF[i][j] * genome[j];</span>
                    }
                }
            /* COMPUTATION core */
<span class="fc bfc" id="L1243" title="All 2 branches covered.">            for (i = 0; i &lt; genomeSize - 1; i++) {</span>
<span class="fc" id="L1244">                tmp2 = tmx[i] * tmx[i] - tmx[i + 1];</span>
<span class="fc" id="L1245">                f2 = 100. * tmp2 * tmp2;</span>
<span class="fc" id="L1246">                tmp2 = 1 - tmx[i];</span>
<span class="fc" id="L1247">                f2 += tmp2 * tmp2;</span>
<span class="fc" id="L1248">                tmp += f2 / 4000. - Math.cos(f2);</span>
                }
<span class="fc" id="L1250">            value = 10. + 10. * tmp / (double) (genomeSize - 1);</span>
            } else {
            /* BOUNDARY HANDLING */
<span class="nc bnc" id="L1253" title="All 2 branches missed.">            for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="nc" id="L1254">                tmp = Math.abs(genome[i]) - 5.0;</span>
<span class="nc bnc" id="L1255" title="All 2 branches missed.">                if (tmp &gt; 0.0) {</span>
<span class="nc" id="L1256">                    fPen += tmp * tmp;</span>
                    }
                }
<span class="nc" id="L1259">            fAdd += 100.0 * fPen;</span>

            /* TRANSFORMATION IN SEARCH SPACE */
<span class="nc bnc" id="L1262" title="All 2 branches missed.">            for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="nc" id="L1263">                tmx[i] = 0.5;</span>
<span class="nc bnc" id="L1264" title="All 2 branches missed.">                for (j = 0; j &lt; genomeSize; j++) {</span>
<span class="nc" id="L1265">                    tmx[i] += scales * rotation[i][j] * genome[j];</span>
                    }
                }
            /* COMPUTATION core */
<span class="nc" id="L1269">            tmp = 0.;</span>
<span class="nc bnc" id="L1270" title="All 2 branches missed.">            for (i = 0; i &lt; genomeSize - 1; i++) {</span>
<span class="nc" id="L1271">                f2 = 100. * (tmx[i] * tmx[i] - tmx[i + 1]) * (tmx[i] * tmx[i] - tmx[i + 1]) + (1 - tmx[i]) * (1 - tmx[i]);</span>
<span class="nc" id="L1272">                tmp += f2 / 4000. - Math.cos(f2);</span>
                }
<span class="nc" id="L1274">            value = 1. + 1. * tmp / (double) (genomeSize - 1);</span>
            }
<span class="pc bpc" id="L1276" title="4 of 5 branches missed.">        switch (noise) {</span>
        case NONE:
<span class="fc" id="L1278">            break;</span>
        case GAUSSIAN:
<span class="nc" id="L1280">            value = fGauss(value, 1.0, state.random[threadnum]);</span>
<span class="nc" id="L1281">            break;</span>
        case UNIFORM:
<span class="nc" id="L1283">            value = fUniform(value, 0.49 + 1.0 / genomeSize, 1.0, state.random[threadnum]);</span>
<span class="nc" id="L1284">            break;</span>
        case CAUCHY:
<span class="nc" id="L1286">            value = fCauchy(value, 1.0, 0.2, state.random[threadnum]);</span>
<span class="nc" id="L1287">            break;</span>
        default:
<span class="nc" id="L1289">            String outputStr = &quot;Invalid value for parameter, or parameter not found.\n&quot; + &quot;Acceptable values are:\n&quot;;</span>
<span class="nc bnc" id="L1290" title="All 2 branches missed.">            for (i = 0; i &lt; 4; i++)</span>
<span class="nc" id="L1291">                outputStr += noiseTypes[i] + &quot;\n&quot;;</span>
<span class="nc" id="L1292">            state.output.fatal(outputStr, new Parameter(P_NOISE));</span>
            break;
            }
<span class="fc" id="L1295">        value += fAdd;</span>
<span class="fc" id="L1296">        fit = (-value);</span>
<span class="pc bpc" id="L1297" title="1 of 2 branches missed.">        ((SimpleFitness) (ind.fitness)).setFitness(state, fit, fit == 0.0);</span>
<span class="fc" id="L1298">        }</span>

    void ellipsoidal_2(double fAdd, int genomeSize, double[] genome, double tmp, double[] tmx, double value, double fit, Individual ind, EvolutionState state, int threadnum) {
        int i, j;
<span class="fc" id="L1302">        double condition = 1e6;</span>

<span class="fc" id="L1304">        fAdd = fOpt;</span>
        /* BOUNDARY HANDLING */

        /* TRANSFORMATION IN SEARCH SPACE */
<span class="fc bfc" id="L1308" title="All 2 branches covered.">        for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc" id="L1309">            tmx[i] = 0.0;</span>
<span class="fc bfc" id="L1310" title="All 2 branches covered.">            for (j = 0; j &lt; genomeSize; j++) {</span>
<span class="fc" id="L1311">                tmx[i] += rotation[i][j] * (genome[j] - xOpt[j]);</span>
                }
            }

<span class="fc" id="L1315">        monotoneTFosc(tmx);</span>
        /* COMPUTATION core */
<span class="fc bfc" id="L1317" title="All 2 branches covered.">        for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc" id="L1318">            fAdd += Math.pow(condition, ((double) i) / ((double) (genomeSize - 1))) * tmx[i] * tmx[i];</span>
            }
<span class="fc" id="L1320">        value = fAdd;</span>
<span class="fc" id="L1321">        fit = (-value);</span>
<span class="pc bpc" id="L1322" title="1 of 2 branches missed.">        ((SimpleFitness) (ind.fitness)).setFitness(state, fit, fit == 0.0);</span>
<span class="fc" id="L1323">        }</span>

    void rastrigin_2(double fAdd, int genomeSize, double[] genome, double tmp, double tmp2, double[] tmx, double[] tmpvect, double fPen, double value, double fit, Individual ind, EvolutionState state, int threadnum) {
        int i, j;
<span class="fc" id="L1327">        double condition = 10.0;</span>
<span class="fc" id="L1328">        double beta = 0.2;</span>
<span class="fc" id="L1329">        tmp = tmp2 = 0;</span>

<span class="fc" id="L1331">        fAdd = fOpt;</span>
        /* BOUNDARY HANDLING */

        /* TRANSFORMATION IN SEARCH SPACE */
<span class="fc bfc" id="L1335" title="All 2 branches covered.">        for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc" id="L1336">            tmpvect[i] = 0.0;</span>
<span class="fc bfc" id="L1337" title="All 2 branches covered.">            for (j = 0; j &lt; genomeSize; j++) {</span>
<span class="fc" id="L1338">                tmpvect[i] += rotation[i][j] * (genome[j] - xOpt[j]);</span>
                }
            }

<span class="fc" id="L1342">        monotoneTFosc(tmpvect);</span>
<span class="fc bfc" id="L1343" title="All 2 branches covered.">        for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc bfc" id="L1344" title="All 2 branches covered.">            if (tmpvect[i] &gt; 0)</span>
<span class="fc" id="L1345">                tmpvect[i] = Math.pow(tmpvect[i], 1 + beta * ((double) i) / ((double) (genomeSize - 1)) * Math.sqrt(tmpvect[i]));</span>
            }
<span class="fc bfc" id="L1347" title="All 2 branches covered.">        for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc" id="L1348">            tmx[i] = 0.0;</span>
<span class="fc bfc" id="L1349" title="All 2 branches covered.">            for (j = 0; j &lt; genomeSize; j++) {</span>
<span class="fc" id="L1350">                tmx[i] += linearTF[i][j] * tmpvect[j];</span>
                }
            }
        /* COMPUTATION core */
<span class="fc bfc" id="L1354" title="All 2 branches covered.">        for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc" id="L1355">            tmp += Math.cos(2. * Math.PI * tmx[i]);</span>
<span class="fc" id="L1356">            tmp2 += tmx[i] * tmx[i];</span>
            }
<span class="fc" id="L1358">        value = 10. * ((double) genomeSize - tmp) + tmp2;</span>
<span class="fc" id="L1359">        value += fAdd;</span>
<span class="fc" id="L1360">        fit = (-value);</span>
<span class="pc bpc" id="L1361" title="1 of 2 branches missed.">        ((SimpleFitness) (ind.fitness)).setFitness(state, fit, fit == 0.0);</span>
<span class="fc" id="L1362">        }</span>

    void discus(double fAdd, int genomeSize, double[] genome, double[] tmx, double value, double fit, Individual ind, EvolutionState state, int threadnum) {
        int i, j;
<span class="fc" id="L1366">        double condition = 1e6;</span>
<span class="fc" id="L1367">        fAdd = fOpt;</span>
        /* BOUNDARY HANDLING */

        /* TRANSFORMATION IN SEARCH SPACE */
<span class="fc bfc" id="L1371" title="All 2 branches covered.">        for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc" id="L1372">            tmx[i] = 0.0;</span>
<span class="fc bfc" id="L1373" title="All 2 branches covered.">            for (j = 0; j &lt; genomeSize; j++) {</span>
<span class="fc" id="L1374">                tmx[i] += rotation[i][j] * (genome[j] - xOpt[j]);</span>
                }
            }

<span class="fc" id="L1378">        monotoneTFosc(tmx);</span>

        /* COMPUTATION core */
<span class="fc" id="L1381">        value = condition * tmx[0] * tmx[0];</span>
<span class="fc bfc" id="L1382" title="All 2 branches covered.">        for (i = 1; i &lt; genomeSize; i++) {</span>
<span class="fc" id="L1383">            value += tmx[i] * tmx[i];</span>
            }
<span class="fc" id="L1385">        value += fAdd; /* without noise */</span>
<span class="fc" id="L1386">        fit = (-value);</span>
<span class="pc bpc" id="L1387" title="1 of 2 branches missed.">        ((SimpleFitness) (ind.fitness)).setFitness(state, fit, fit == 0.0);</span>
<span class="fc" id="L1388">        }</span>

    void bent_cigar(double fAdd, int genomeSize, double[] genome, double[] tmx, double[] tmpvect, double value, double fit, Individual ind, EvolutionState state, int threadnum) {
        int i, j;
<span class="fc" id="L1392">        double condition = 1e6;</span>
<span class="fc" id="L1393">        double beta = 0.5;</span>
<span class="fc" id="L1394">        fAdd = fOpt;</span>
        /* BOUNDARY HANDLING */

        /* TRANSFORMATION IN SEARCH SPACE */
<span class="fc bfc" id="L1398" title="All 2 branches covered.">        for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc" id="L1399">            tmpvect[i] = 0.0;</span>
<span class="fc bfc" id="L1400" title="All 2 branches covered.">            for (j = 0; j &lt; genomeSize; j++) {</span>
<span class="fc" id="L1401">                tmpvect[i] += rotation[i][j] * (genome[j] - xOpt[j]);</span>
                }
<span class="fc bfc" id="L1403" title="All 2 branches covered.">            if (tmpvect[i] &gt; 0) {</span>
<span class="fc" id="L1404">                tmpvect[i] = Math.pow(tmpvect[i], 1 + beta * ((double) i) / ((double) (genomeSize - 1)) * Math.sqrt(tmpvect[i]));</span>
                }
            }

<span class="fc bfc" id="L1408" title="All 2 branches covered.">        for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc" id="L1409">            tmx[i] = 0.0;</span>
<span class="fc bfc" id="L1410" title="All 2 branches covered.">            for (j = 0; j &lt; genomeSize; j++) {</span>
<span class="fc" id="L1411">                tmx[i] += rotation[i][j] * tmpvect[j];</span>
                }
            }

        /* COMPUTATION core */
<span class="fc" id="L1416">        value = tmx[0] * tmx[0];</span>
<span class="fc bfc" id="L1417" title="All 2 branches covered.">        for (i = 1; i &lt; genomeSize; i++) {</span>
<span class="fc" id="L1418">            value += condition * tmx[i] * tmx[i];</span>
            }
<span class="fc" id="L1420">        value += fAdd;</span>
<span class="fc" id="L1421">        fit = (-value);</span>
<span class="pc bpc" id="L1422" title="1 of 2 branches missed.">        ((SimpleFitness) (ind.fitness)).setFitness(state, fit, fit == 0.0);</span>
<span class="fc" id="L1423">        }</span>

    void sharp_ridge(double fAdd, int genomeSize, double[] genome, double[] tmx, double value, double fit, Individual ind, EvolutionState state, int threadnum) {
        int i, j;
<span class="fc" id="L1427">        double condition = 10.0;</span>
<span class="fc" id="L1428">        double alpha = 100.0;</span>

<span class="fc" id="L1430">        fAdd = fOpt;</span>
        /* BOUNDARY HANDLING */

        /* TRANSFORMATION IN SEARCH SPACE */
<span class="fc bfc" id="L1434" title="All 2 branches covered.">        for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc" id="L1435">            tmx[i] = 0.0;</span>
<span class="fc bfc" id="L1436" title="All 2 branches covered.">            for (j = 0; j &lt; genomeSize; j++) {</span>
<span class="fc" id="L1437">                tmx[i] += linearTF[i][j] * (genome[j] - xOpt[j]);</span>
                }
            }

        /* COMPUTATION core */
<span class="fc bfc" id="L1442" title="All 2 branches covered.">        for (i = 1; i &lt; genomeSize; i++) {</span>
<span class="fc" id="L1443">            value += tmx[i] * tmx[i];</span>
            }
<span class="fc" id="L1445">        value = alpha * Math.sqrt(value);</span>
<span class="fc" id="L1446">        value += tmx[0] * tmx[0];</span>
<span class="fc" id="L1447">        value += fAdd;</span>
<span class="fc" id="L1448">        fit = (-value);</span>
<span class="pc bpc" id="L1449" title="1 of 2 branches missed.">        ((SimpleFitness) (ind.fitness)).setFitness(state, fit, fit == 0.0);</span>
<span class="fc" id="L1450">        }</span>

    void different_powers(double fAdd, int genomeSize, double[] genome, double tmp, double[] tmx, double fPen, double value, double fit, Individual ind, EvolutionState state, int threadnum) {
        int i, j;
<span class="fc" id="L1454">        double alpha = 4.0;</span>
<span class="fc" id="L1455">        fAdd = fOpt;</span>
<span class="pc bpc" id="L1456" title="1 of 2 branches missed.">        if (noise != NONE) {</span>
            /* BOUNDARY HANDLING */
<span class="nc bnc" id="L1458" title="All 2 branches missed.">            for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="nc" id="L1459">                tmp = Math.abs(genome[i]) - 5.;</span>
<span class="nc bnc" id="L1460" title="All 2 branches missed.">                if (tmp &gt; 0.) {</span>
<span class="nc" id="L1461">                    fPen += tmp * tmp;</span>
                    }
                }
<span class="nc" id="L1464">            fAdd += 100. * fPen;</span>
            }

        /* TRANSFORMATION IN SEARCH SPACE */
<span class="fc bfc" id="L1468" title="All 2 branches covered.">        for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc" id="L1469">            tmx[i] = 0.0;</span>
<span class="fc bfc" id="L1470" title="All 2 branches covered.">            for (j = 0; j &lt; genomeSize; j++) {</span>
<span class="fc" id="L1471">                tmx[i] += rotation[i][j] * (genome[j] - xOpt[j]);</span>
                }
            }

        /* COMPUTATION core */
<span class="fc bfc" id="L1476" title="All 2 branches covered.">        for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc" id="L1477">            value += Math.pow(Math.abs(tmx[i]), 2. + alpha * ((double) i) / ((double) (genomeSize - 1)));</span>
            }
<span class="fc" id="L1479">        value = Math.sqrt(value);</span>
<span class="pc bpc" id="L1480" title="4 of 5 branches missed.">        switch (noise) {</span>
        case NONE:
<span class="fc" id="L1482">            break;</span>
        case GAUSSIAN:
<span class="nc" id="L1484">            value = fGauss(value, 1.0, state.random[threadnum]);</span>
<span class="nc" id="L1485">            break;</span>
        case UNIFORM:
<span class="nc" id="L1487">            value = fUniform(value, 0.49 + 1.0 / genomeSize, 1.0, state.random[threadnum]);</span>
<span class="nc" id="L1488">            break;</span>
        case CAUCHY:
<span class="nc" id="L1490">            value = fCauchy(value, 1.0, 0.2, state.random[threadnum]);</span>
<span class="nc" id="L1491">            break;</span>
        default:
<span class="nc" id="L1493">            String outputStr = &quot;Invalid value for parameter, or parameter not found.\n&quot; + &quot;Acceptable values are:\n&quot;;</span>
<span class="nc bnc" id="L1494" title="All 2 branches missed.">            for (i = 0; i &lt; 4; i++)</span>
<span class="nc" id="L1495">                outputStr += noiseTypes[i] + &quot;\n&quot;;</span>
<span class="nc" id="L1496">            state.output.fatal(outputStr, new Parameter(P_NOISE));</span>
            break;
            }
<span class="fc" id="L1499">        value += fAdd;</span>
<span class="fc" id="L1500">        fit = (-value);</span>
<span class="pc bpc" id="L1501" title="1 of 2 branches missed.">        ((SimpleFitness) (ind.fitness)).setFitness(state, fit, fit == 0.0);</span>
<span class="fc" id="L1502">        }</span>

    void weierstrass(double fAdd, int genomeSize, double[] genome, double tmp, double[] tmx, double[] tmpvect, double fPen, double value, double fit, Individual ind, EvolutionState state, int threadnum) {
        int i, j;
<span class="fc" id="L1506">        double condition = 100.0;</span>
<span class="fc" id="L1507">        fPen = 0;</span>

<span class="fc" id="L1509">        fAdd = fOpt;</span>

        /* BOUNDARY HANDLING */
<span class="fc bfc" id="L1512" title="All 2 branches covered.">        for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc" id="L1513">            tmp = Math.abs(genome[i]) - 5.;</span>
<span class="pc bpc" id="L1514" title="1 of 2 branches missed.">            if (tmp &gt; 0.) {</span>
<span class="nc" id="L1515">                fPen += tmp * tmp;</span>
                }
            }
<span class="fc" id="L1518">        fAdd += 10. / (double) genomeSize * fPen;</span>

        /* TRANSFORMATION IN SEARCH SPACE */
<span class="fc bfc" id="L1521" title="All 2 branches covered.">        for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc" id="L1522">            tmpvect[i] = 0.0;</span>
<span class="fc bfc" id="L1523" title="All 2 branches covered.">            for (j = 0; j &lt; genomeSize; j++) {</span>
<span class="fc" id="L1524">                tmpvect[i] += rotation[i][j] * (genome[j] - xOpt[j]);</span>
                }
            }

<span class="fc" id="L1528">        monotoneTFosc(tmpvect);</span>
<span class="fc bfc" id="L1529" title="All 2 branches covered.">        for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc" id="L1530">            tmx[i] = 0.0;</span>
<span class="fc bfc" id="L1531" title="All 2 branches covered.">            for (j = 0; j &lt; genomeSize; j++) {</span>
<span class="fc" id="L1532">                tmx[i] += linearTF[i][j] * tmpvect[j];</span>
                }
            }
        /* COMPUTATION core */
<span class="fc bfc" id="L1536" title="All 2 branches covered.">        for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc" id="L1537">            tmp = 0.0;</span>
<span class="fc bfc" id="L1538" title="All 2 branches covered.">            for (j = 0; j &lt; 12; j++) {</span>
<span class="fc" id="L1539">                tmp += Math.cos(2 * Math.PI * (tmx[i] + 0.5) * bK[j]) * aK[j];</span>
                }
<span class="fc" id="L1541">            value += tmp;</span>
            }
<span class="fc" id="L1543">        value = 10. * Math.pow(value / (double) genomeSize - f0, 3.);</span>
<span class="fc" id="L1544">        value += fAdd;</span>
        ;

<span class="fc" id="L1547">        fit = (-value);</span>
<span class="pc bpc" id="L1548" title="1 of 2 branches missed.">        ((SimpleFitness) (ind.fitness)).setFitness(state, fit, fit == 0.0);</span>
<span class="fc" id="L1549">        }</span>

    void schwefel(double fAdd, int genomeSize, double[] genome, double tmp, double[] tmx, double[] tmpvect, double fPen, double value, double fit, Individual ind, EvolutionState state, int threadnum) {
        int i, j;
<span class="fc" id="L1553">        double condition = 10.0;</span>
<span class="fc" id="L1554">        fPen = 0.0;</span>
<span class="fc" id="L1555">        fAdd = fOpt;</span>

        /* TRANSFORMATION IN SEARCH SPACE */
<span class="fc bfc" id="L1558" title="All 2 branches covered.">        for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc" id="L1559">            tmpvect[i] = 2. * genome[i];</span>
<span class="fc bfc" id="L1560" title="All 2 branches covered.">            if (xOpt[i] &lt; 0.)</span>
<span class="fc" id="L1561">                tmpvect[i] *= -1.;</span>
            }

<span class="fc" id="L1564">        tmx[0] = tmpvect[0];</span>
<span class="fc bfc" id="L1565" title="All 2 branches covered.">        for (i = 1; i &lt; genomeSize; i++) {</span>
<span class="fc" id="L1566">            tmx[i] = tmpvect[i] + 0.25 * (tmpvect[i - 1] - 2. * Math.abs(xOpt[i - 1]));</span>
            }

<span class="fc bfc" id="L1569" title="All 2 branches covered.">        for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc" id="L1570">            tmx[i] -= 2 * Math.abs(xOpt[i]);</span>
<span class="fc" id="L1571">            tmx[i] *= Math.pow(Math.sqrt(condition), ((double) i) / ((double) (genomeSize - 1)));</span>
<span class="fc" id="L1572">            tmx[i] = 100. * (tmx[i] + 2 * Math.abs(xOpt[i]));</span>
            }

        /* BOUNDARY HANDLING */
<span class="fc bfc" id="L1576" title="All 2 branches covered.">        for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc" id="L1577">            tmp = Math.abs(tmx[i]) - 500.0;</span>
<span class="fc bfc" id="L1578" title="All 2 branches covered.">            if (tmp &gt; 0.) {</span>
<span class="fc" id="L1579">                fPen += tmp * tmp;</span>
                }
            }
<span class="fc" id="L1582">        fAdd += 0.01 * fPen;</span>

        /* COMPUTATION core */
<span class="fc bfc" id="L1585" title="All 2 branches covered.">        for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc" id="L1586">            value += tmx[i] * Math.sin(Math.sqrt(Math.abs(tmx[i])));</span>
            }
<span class="fc" id="L1588">        value = 0.01 * ((418.9828872724339) - value / (double) genomeSize);</span>
<span class="fc" id="L1589">        value += fAdd;/* without noise */</span>
<span class="fc" id="L1590">        fit = (-value);</span>
<span class="pc bpc" id="L1591" title="1 of 2 branches missed.">        ((SimpleFitness) (ind.fitness)).setFitness(state, fit, fit == 0.0);</span>
<span class="fc" id="L1592">        }</span>

    void gallagher_gaussian_101me(double fAdd, int genomeSize, double[] genome, double tmp, double[] tmx, double tmp2, double f, double fPen, double value, double fit, Individual ind, EvolutionState state, int threadnum) {
        int i, j;
<span class="fc" id="L1596">        double a = 0.1;</span>
<span class="fc" id="L1597">        double fac = -0.5 / (double) genomeSize;</span>
<span class="fc" id="L1598">        fAdd = fOpt;</span>

        /* BOUNDARY HANDLING */
<span class="fc bfc" id="L1601" title="All 2 branches covered.">        for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc" id="L1602">            tmp = Math.abs(genome[i]) - 5.;</span>
<span class="pc bpc" id="L1603" title="1 of 2 branches missed.">            if (tmp &gt; 0.) {</span>
<span class="nc" id="L1604">                fPen += tmp * tmp;</span>
                }
            }
<span class="pc bpc" id="L1607" title="1 of 2 branches missed.">        if (noise == NONE)</span>
<span class="fc" id="L1608">            fAdd += fPen;</span>
        else
<span class="nc" id="L1610">            fAdd += 100. * fPen;</span>

        /* TRANSFORMATION IN SEARCH SPACE */
<span class="fc bfc" id="L1613" title="All 2 branches covered.">        for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc" id="L1614">            tmx[i] = 0.0;</span>
<span class="fc bfc" id="L1615" title="All 2 branches covered.">            for (j = 0; j &lt; genomeSize; j++) {</span>
<span class="fc" id="L1616">                tmx[i] += rotation[i][j] * genome[j];</span>
                }
            }

        /* COMPUTATION core */
<span class="pc bpc" id="L1621" title="1 of 2 branches missed.">        if (noise == NONE)</span>
<span class="fc bfc" id="L1622" title="All 2 branches covered.">            for (i = 0; i &lt; NHIGHPEAKS21; i++) {</span>
<span class="fc" id="L1623">                tmp2 = 0.0;</span>
<span class="fc bfc" id="L1624" title="All 2 branches covered.">                for (j = 0; j &lt; genomeSize; j++) {</span>
<span class="fc" id="L1625">                    tmp = (tmx[j] - xLocal[j][i]);</span>
<span class="fc" id="L1626">                    tmp2 += arrScales[i][j] * tmp * tmp;</span>
                    }
<span class="fc" id="L1628">                tmp2 = peakvalues[i] * Math.exp(fac * tmp2);</span>
<span class="fc" id="L1629">                f = Math.max(f, tmp2);</span>
                }
        else
            /* COMPUTATION core */
<span class="nc bnc" id="L1633" title="All 2 branches missed.">            for (i = 0; i &lt; NHIGHPEAKS21; i++) {</span>
<span class="nc" id="L1634">                tmp2 = 0.;</span>
<span class="nc bnc" id="L1635" title="All 2 branches missed.">                for (j = 0; j &lt; genomeSize; j++) {</span>
<span class="nc" id="L1636">                    tmp2 += arrScales[i][j] * (tmx[j] - xLocal[j][i]) * (tmx[j] - xLocal[j][i]);</span>
                    }
<span class="nc" id="L1638">                tmp2 = peakvalues[i] * Math.exp(fac * tmp2);</span>
<span class="nc" id="L1639">                f = Math.max(f, tmp2);</span>
                }

<span class="fc" id="L1642">        f = 10.0 - f;</span>
        /* monotoneTFosc */
<span class="pc bpc" id="L1644" title="1 of 2 branches missed.">        if (f &gt; 0) {</span>
<span class="fc" id="L1645">            value = Math.log(f) / a;</span>
<span class="fc" id="L1646">            value = Math.pow(Math.exp(value + 0.49 * (Math.sin(value) + Math.sin(0.79 * value))), a);</span>
<span class="nc bnc" id="L1647" title="All 2 branches missed.">            } else if (f &lt; 0) {</span>
<span class="nc" id="L1648">            value = Math.log(-f) / a;</span>
<span class="nc" id="L1649">            value = -Math.pow(Math.exp(value + 0.49 * (Math.sin(0.55 * value) + Math.sin(0.31 * value))), a);</span>
            } else
<span class="nc" id="L1651">            value = f;</span>

<span class="fc" id="L1653">        value *= value;</span>
<span class="pc bpc" id="L1654" title="4 of 5 branches missed.">        switch (noise) {</span>
        case NONE:
<span class="fc" id="L1656">            break;</span>
        case GAUSSIAN:
<span class="nc" id="L1658">            value = fGauss(value, 1.0, state.random[threadnum]);</span>
<span class="nc" id="L1659">            break;</span>
        case UNIFORM:
<span class="nc" id="L1661">            value = fUniform(value, 0.49 + 1.0 / genomeSize, 1.0, state.random[threadnum]);</span>
<span class="nc" id="L1662">            break;</span>
        case CAUCHY:
<span class="nc" id="L1664">            value = fCauchy(value, 1.0, 0.2, state.random[threadnum]);</span>
<span class="nc" id="L1665">            break;</span>
        default:
<span class="nc" id="L1667">            String outputStr = &quot;Invalid value for parameter, or parameter not found.\n&quot; + &quot;Acceptable values are:\n&quot;;</span>
<span class="nc bnc" id="L1668" title="All 2 branches missed.">            for (i = 0; i &lt; 4; i++)</span>
<span class="nc" id="L1669">                outputStr += noiseTypes[i] + &quot;\n&quot;;</span>
<span class="nc" id="L1670">            state.output.fatal(outputStr, new Parameter(P_NOISE));</span>
            break;
            }
<span class="fc" id="L1673">        value += fAdd;</span>
        ; /* without noise */

<span class="fc" id="L1676">        fit = (-value);</span>
<span class="pc bpc" id="L1677" title="1 of 2 branches missed.">        ((SimpleFitness) (ind.fitness)).setFitness(state, fit, fit == 0.0);</span>
<span class="fc" id="L1678">        }</span>

    void gallagher_gaussian_21hi(double fAdd, int genomeSize, double[] genome, double tmp, double[] tmx, double tmp2, double fPen, double value, double fit, Individual ind, EvolutionState state, int threadnum) {
        int i, j;
<span class="fc" id="L1682">        double a = 0.1;</span>
<span class="fc" id="L1683">        double f = 0;</span>
<span class="fc" id="L1684">        double fac = -0.5 / (double) genomeSize;</span>
<span class="fc" id="L1685">        fPen = 0.0;</span>

<span class="fc" id="L1687">        fAdd = fOpt;</span>

        /* BOUNDARY HANDLING */
<span class="fc bfc" id="L1690" title="All 2 branches covered.">        for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc" id="L1691">            tmp = Math.abs(genome[i]) - 5.;</span>
<span class="pc bpc" id="L1692" title="1 of 2 branches missed.">            if (tmp &gt; 0.) {</span>
<span class="nc" id="L1693">                fPen += tmp * tmp;</span>
                }
            }
<span class="fc" id="L1696">        fAdd += fPen;</span>

        /* TRANSFORMATION IN SEARCH SPACE */
<span class="fc bfc" id="L1699" title="All 2 branches covered.">        for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc" id="L1700">            tmx[i] = 0.0;</span>
<span class="fc bfc" id="L1701" title="All 2 branches covered.">            for (j = 0; j &lt; genomeSize; j++) {</span>
<span class="fc" id="L1702">                tmx[i] += rotation[i][j] * genome[j];</span>
                }
            }

        /* COMPUTATION core */
<span class="fc bfc" id="L1707" title="All 2 branches covered.">        for (i = 0; i &lt; NHIGHPEAKS22; i++) {</span>
<span class="fc" id="L1708">            tmp2 = 0.0;</span>
<span class="fc bfc" id="L1709" title="All 2 branches covered.">            for (j = 0; j &lt; genomeSize; j++) {</span>
<span class="fc" id="L1710">                tmp = (tmx[j] - xLocal[j][i]);</span>
<span class="fc" id="L1711">                tmp2 += arrScales[i][j] * tmp * tmp;</span>
                }
<span class="fc" id="L1713">            tmp2 = peakvalues[i] * Math.exp(fac * tmp2);</span>
<span class="fc" id="L1714">            f = Math.max(f, tmp2);</span>
            }

<span class="fc" id="L1717">        f = 10. - f;</span>
<span class="pc bpc" id="L1718" title="1 of 2 branches missed.">        if (f &gt; 0) {</span>
<span class="fc" id="L1719">            value = Math.log(f) / a;</span>
<span class="fc" id="L1720">            value = Math.pow(Math.exp(value + 0.49 * (Math.sin(value) + Math.sin(0.79 * value))), a);</span>
<span class="nc bnc" id="L1721" title="All 2 branches missed.">            } else if (f &lt; 0) {</span>
<span class="nc" id="L1722">            value = Math.log(-f) / a;</span>
<span class="nc" id="L1723">            value = -Math.pow(Math.exp(value + 0.49 * (Math.sin(0.55 * value) + Math.sin(0.31 * value))), a);</span>
            } else
<span class="nc" id="L1725">            value = f;</span>

<span class="fc" id="L1727">        value *= value;</span>
<span class="fc" id="L1728">        value += fAdd;</span>
        ; /* without noise */

<span class="fc" id="L1731">        fit = (-value);</span>
<span class="pc bpc" id="L1732" title="1 of 2 branches missed.">        ((SimpleFitness) (ind.fitness)).setFitness(state, fit, fit == 0.0);</span>
<span class="fc" id="L1733">        }</span>

    void katsuura(double fAdd, int genomeSize, double[] genome, double tmp, double tmp2, double[] tmx, double[] tmpvect, double fPen, double value, double fit, Individual ind, EvolutionState state, int threadnum) {
        int i, j;
<span class="fc" id="L1737">        double condition = 100.0;</span>
<span class="fc" id="L1738">        fAdd = 0;</span>
<span class="fc" id="L1739">        fPen = 0;</span>
        double arr;
<span class="fc" id="L1741">        double prod = 1.0;</span>
        double[] ptmx,
            plinTF,
            ptmp;

<span class="fc" id="L1746">        fAdd = fOpt;</span>

        /* BOUNDARY HANDLING */
<span class="fc bfc" id="L1749" title="All 2 branches covered.">        for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc" id="L1750">            tmp = Math.abs(genome[i]) - 5.;</span>
<span class="pc bpc" id="L1751" title="1 of 2 branches missed.">            if (tmp &gt; 0.) {</span>
<span class="nc" id="L1752">                fPen += tmp * tmp;</span>
                }
            }
<span class="fc" id="L1755">        fAdd += fPen;</span>

        /* TRANSFORMATION IN SEARCH SPACE */
        /* write rotated difference vector into tmx */
<span class="fc bfc" id="L1759" title="All 2 branches covered.">        for (j = 0; j &lt; genomeSize; j++)</span>
            /* store difference vector */
<span class="fc" id="L1761">            tmpvect[j] = genome[j] - xOpt[j];</span>
<span class="fc bfc" id="L1762" title="All 2 branches covered.">        for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc" id="L1763">            tmx[i] = 0.0;</span>
<span class="fc" id="L1764">            ptmx = tmx;</span>
<span class="fc" id="L1765">            plinTF = linearTF[i];</span>
<span class="fc" id="L1766">            ptmp = tmpvect;</span>
<span class="fc bfc" id="L1767" title="All 2 branches covered.">            for (j = 0; j &lt; genomeSize; j++) {</span>
                // *ptmx += *plinTF++ * *ptmp++;
<span class="fc" id="L1769">                ptmx[j] += plinTF[j] * ptmp[j];</span>
                }
            }

        /*
         * for (i = 0; i &lt; genomeSize; i++) { tmx[i] = 0.0; for (j = 0; j &lt;
         * genomeSize; j++) { tmx[i] += linearTF[i][j] * (genome[j] -
         * xOpt[j]); } }
         */

        /* COMPUTATION core */
<span class="fc bfc" id="L1780" title="All 2 branches covered.">        for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc" id="L1781">            tmp = 0.0;</span>
<span class="fc bfc" id="L1782" title="All 2 branches covered.">            for (j = 1; j &lt; 33; j++) {</span>
<span class="fc" id="L1783">                tmp2 = Math.pow(2., (double) j);</span>
<span class="fc" id="L1784">                arr = tmx[i] * tmp2;</span>
<span class="fc" id="L1785">                tmp += Math.abs(arr - Math.round(arr)) / tmp2;</span>
                }
<span class="fc" id="L1787">            tmp = 1. + tmp * (double) (i + 1);</span>
<span class="fc" id="L1788">            prod *= tmp;</span>
            }
<span class="fc" id="L1790">        value = 10. / (double) genomeSize / (double) genomeSize * (-1. + Math.pow(prod, 10. / Math.pow((double) genomeSize, 1.2)));</span>
<span class="fc" id="L1791">        value += fAdd;</span>
<span class="fc" id="L1792">        fit = (-value);</span>
<span class="pc bpc" id="L1793" title="1 of 2 branches missed.">        ((SimpleFitness) (ind.fitness)).setFitness(state, fit, fit == 0.0);</span>
<span class="fc" id="L1794">        }</span>

    void lunacek(double fAdd, int genomeSize, double[] genome, double tmp, double tmp2, double condition, double[] tmx, double fPen, double value, double fit, Individual ind, EvolutionState state, int threadnum) {
        int i, j;
        /* Lunacek bi-Rastrigin, condition 100 */
        /* in PPSN 2008, Rastrigin part rotated and scaled */
<span class="fc" id="L1800">        condition = 100.0;</span>
<span class="fc" id="L1801">        double mu1 = 2.5;</span>
        double tmp3,
            tmp4;
<span class="fc" id="L1804">        fPen = tmp2 = tmp3 = tmp4 = 0.0;</span>
<span class="fc" id="L1805">        double s = 1. - 0.5 / (Math.sqrt((double) (genomeSize + 20)) - 4.1);</span>
<span class="fc" id="L1806">        double d = 1.;</span>
<span class="fc" id="L1807">        double mu2 = -Math.sqrt((mu1 * mu1 - d) / s);</span>

<span class="fc" id="L1809">        fAdd = fOpt;</span>

        /* BOUNDARY HANDLING */
<span class="fc bfc" id="L1812" title="All 2 branches covered.">        for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc" id="L1813">            tmp = Math.abs(genome[i]) - 5.;</span>
<span class="pc bpc" id="L1814" title="1 of 2 branches missed.">            if (tmp &gt; 0.) {</span>
<span class="nc" id="L1815">                fPen += tmp * tmp;</span>
                }
            }
<span class="fc" id="L1818">        fAdd += 1e4 * fPen;</span>

        /* TRANSFORMATION IN SEARCH SPACE */
<span class="fc bfc" id="L1821" title="All 2 branches covered.">        for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc" id="L1822">            tmx[i] = 2. * genome[i];</span>
<span class="fc bfc" id="L1823" title="All 2 branches covered.">            if (xOpt[i] &lt; 0.)</span>
<span class="fc" id="L1824">                tmx[i] *= -1.;</span>
            }

        /* COMPUTATION core */
<span class="fc" id="L1828">        tmp = 0.0;</span>
<span class="fc bfc" id="L1829" title="All 2 branches covered.">        for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc" id="L1830">            tmp2 += (tmx[i] - mu1) * (tmx[i] - mu1);</span>
<span class="fc" id="L1831">            tmp3 += (tmx[i] - mu2) * (tmx[i] - mu2);</span>
<span class="fc" id="L1832">            tmp4 = 0.0;</span>
<span class="fc bfc" id="L1833" title="All 2 branches covered.">            for (j = 0; j &lt; genomeSize; j++) {</span>
<span class="fc" id="L1834">                tmp4 += linearTF[i][j] * (tmx[j] - mu1);</span>
                }
<span class="fc" id="L1836">            tmp += Math.cos(2 * Math.PI * tmp4);</span>
            }
<span class="fc" id="L1838">        value = Math.min(tmp2, d * (double) genomeSize + s * tmp3) + 10. * ((double) genomeSize - tmp);</span>
<span class="fc" id="L1839">        value += fAdd;</span>
<span class="fc" id="L1840">        fit = (-value);</span>
<span class="pc bpc" id="L1841" title="1 of 2 branches missed.">        ((SimpleFitness) (ind.fitness)).setFitness(state, fit, fit == 0.0);</span>
<span class="fc" id="L1842">        }</span>


    final static public double TOL = 1e-8;

    void gauss(double[] g, MersenneTwisterFast random) {
        /*
         * samples N standard normally distributed numbers being the same for a
         * given seed.
         */
<span class="fc" id="L1852">        double[] uniftmp = new double[2 * g.length];</span>
        int i;
<span class="fc bfc" id="L1854" title="All 2 branches covered.">        for (i = 0; i &lt; uniftmp.length; i++)</span>
<span class="fc" id="L1855">            uniftmp[i] = nextDoubleClosedInterval(random);</span>
<span class="fc bfc" id="L1856" title="All 2 branches covered.">        for (i = 0; i &lt; g.length; i++) {</span>

<span class="fc" id="L1858">            g[i] = Math.sqrt(-2 * Math.log(uniftmp[i])) * Math.cos(2 * Math.PI * uniftmp[g.length + i]);</span>
<span class="pc bpc" id="L1859" title="1 of 2 branches missed.">            if (g[i] == 0.0)</span>
<span class="nc" id="L1860">                g[i] = 1e-99;</span>
            }
<span class="fc" id="L1862">        return;</span>
        }

    void gauss(double[] g, MersenneTwisterFast random, int n) {
        /*
         * samples N standard normally distributed numbers being the same for a
         * given seed.
         */
<span class="fc" id="L1870">        double[] uniftmp = new double[2 * g.length];</span>
        int i;
<span class="fc bfc" id="L1872" title="All 2 branches covered.">        for (i = 0; i &lt; uniftmp.length; i++)</span>
<span class="fc" id="L1873">            uniftmp[i] = nextDoubleClosedInterval(random);</span>
<span class="fc bfc" id="L1874" title="All 2 branches covered.">        for (i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L1875">            g[i] = Math.sqrt(-2 * Math.log(uniftmp[i])) * Math.cos(2 * Math.PI * uniftmp[n + i]);</span>
<span class="pc bpc" id="L1876" title="1 of 2 branches missed.">            if (g[i] == 0.0)</span>
<span class="nc" id="L1877">                g[i] = 1e-99;</span>
            }
<span class="fc" id="L1879">        return;</span>
        }

    void computeXopt(double[] xOpt, MersenneTwisterFast random) {
        int i;
<span class="fc" id="L1884">        int n = xOpt.length;</span>
<span class="fc bfc" id="L1885" title="All 2 branches covered.">        for (i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L1886">            xOpt[i] = 8 * (int) Math.floor(1e4 * nextDoubleClosedInterval(random)) / 1e4 - 4;</span>
<span class="fc bfc" id="L1887" title="All 2 branches covered.">            if (xOpt[i] == 0.0)</span>
<span class="fc" id="L1888">                xOpt[i] = -1e-5;</span>
            }
<span class="fc" id="L1890">        }</span>

    void monotoneTFosc(double[] f) {
<span class="fc" id="L1893">        double a = 0.1;</span>
        int i;
<span class="fc" id="L1895">        int n = f.length;</span>
<span class="fc bfc" id="L1896" title="All 2 branches covered.">        for (i = 0; i &lt; n; i++) {</span>
<span class="fc bfc" id="L1897" title="All 2 branches covered.">            if (f[i] &gt; 0) {</span>
<span class="fc" id="L1898">                f[i] = Math.log(f[i]) / a;</span>
<span class="fc" id="L1899">                f[i] = Math.pow(Math.exp(f[i] + 0.49 * (Math.sin(f[i]) + Math.sin(0.79 * f[i]))), a);</span>
<span class="pc bpc" id="L1900" title="1 of 2 branches missed.">                } else if (f[i] &lt; 0) {</span>
<span class="fc" id="L1901">                f[i] = Math.log(-f[i]) / a;</span>
<span class="fc" id="L1902">                f[i] = -Math.pow(Math.exp(f[i] + 0.49 * (Math.sin(0.55 * f[i]) + Math.sin(0.31 * f[i]))), a);</span>
                }
            }
<span class="fc" id="L1905">        }</span>

    double[][] reshape(double[][] b, double[] vector, int m, int n) {
        int i, j;
<span class="fc bfc" id="L1909" title="All 2 branches covered.">        for (i = 0; i &lt; m; i++) {</span>
<span class="fc bfc" id="L1910" title="All 2 branches covered.">            for (j = 0; j &lt; n; j++) {</span>
<span class="fc" id="L1911">                b[i][j] = vector[j * m + i];</span>
                }
            }
<span class="fc" id="L1914">        return b;</span>
        }

    void computeRotation(double[][] b, MersenneTwisterFast random, int genomeSize) {
<span class="fc" id="L1918">        double[] gvect = new double[genomeSize * genomeSize];</span>
        double prod;
        int i, j, k; /* Loop over pairs of column vectors */

<span class="fc" id="L1922">        gauss(gvect, random);</span>
<span class="fc" id="L1923">        reshape(b, gvect, genomeSize, genomeSize);</span>
        /* 1st coordinate is row, 2nd is column. */

<span class="fc bfc" id="L1926" title="All 2 branches covered.">        for (i = 0; i &lt; genomeSize; i++) {</span>
<span class="fc bfc" id="L1927" title="All 2 branches covered.">            for (j = 0; j &lt; i; j++) {</span>
<span class="fc" id="L1928">                prod = 0;</span>
<span class="fc bfc" id="L1929" title="All 2 branches covered.">                for (k = 0; k &lt; genomeSize; k++) {</span>
<span class="fc" id="L1930">                    prod += b[k][i] * b[k][j];</span>
                    }
<span class="fc bfc" id="L1932" title="All 2 branches covered.">                for (k = 0; k &lt; genomeSize; k++) {</span>
<span class="fc" id="L1933">                    b[k][i] -= prod * b[k][j];</span>
                    }
                }
<span class="fc" id="L1936">            prod = 0;</span>
<span class="fc bfc" id="L1937" title="All 2 branches covered.">            for (k = 0; k &lt; genomeSize; k++) {</span>
<span class="fc" id="L1938">                prod += b[k][i] * b[k][i];</span>
                }
<span class="fc bfc" id="L1940" title="All 2 branches covered.">            for (k = 0; k &lt; genomeSize; k++) {</span>
<span class="fc" id="L1941">                b[k][i] /= Math.sqrt(prod);</span>
                }
            }
<span class="fc" id="L1944">        }</span>

    double fGauss(double fTrue, double beta, MersenneTwisterFast random) {
<span class="nc" id="L1947">        double fVal = fTrue * Math.exp(beta * nextDoubleClosedInterval(random));</span>
<span class="nc" id="L1948">        fVal += 1.01 * TOL;</span>
<span class="nc bnc" id="L1949" title="All 2 branches missed.">        if (fTrue &lt; TOL) {</span>
<span class="nc" id="L1950">            fVal = fTrue;</span>
            }
<span class="nc" id="L1952">        return fVal;</span>
        }

    double fUniform(double fTrue, double alpha, double beta, MersenneTwisterFast random) {
<span class="nc" id="L1956">        double fVal = Math.pow(nextDoubleClosedInterval(random), beta) * fTrue * Math.max(1.0, Math.pow(1e9 / (fTrue + 1e-99), alpha * nextDoubleClosedInterval(random)));</span>
<span class="nc" id="L1957">        fVal += 1.01 * TOL;</span>
<span class="nc bnc" id="L1958" title="All 2 branches missed.">        if (fTrue &lt; TOL) {</span>
<span class="nc" id="L1959">            fVal = fTrue;</span>
            }
<span class="nc" id="L1961">        return fVal;</span>
        }

    double fCauchy(double fTrue, double alpha, double p, MersenneTwisterFast random) {
        double fVal;
<span class="nc" id="L1966">        double tmp = nextDoubleClosedInterval(random) / Math.abs(nextDoubleClosedInterval(random) + 1e-199);</span>
        /*
         * tmp is so as to actually do the calls to randn in order for the
         * number of calls to be the same as in the Matlab code.
         */
<span class="nc bnc" id="L1971" title="All 2 branches missed.">        if (nextDoubleClosedInterval(random) &lt; p)</span>
<span class="nc" id="L1972">            fVal = fTrue + alpha * Math.max(0., 1e3 + tmp);</span>
        else
<span class="nc" id="L1974">            fVal = fTrue + alpha * 1e3;</span>

<span class="nc" id="L1976">        fVal += 1.01 * TOL;</span>
<span class="nc bnc" id="L1977" title="All 2 branches missed.">        if (fTrue &lt; TOL) {</span>
<span class="nc" id="L1978">            fVal = fTrue;</span>
            }
<span class="nc" id="L1980">        return fVal;</span>
        }

    double computeFopt(MersenneTwisterFast random) {
<span class="fc" id="L1984">        double[] gval = new double[1];</span>
<span class="fc" id="L1985">        double[] gval2 = new double[1];</span>
<span class="fc" id="L1986">        gauss(gval, random, 1);</span>
<span class="fc" id="L1987">        gauss(gval2, random, 1);</span>
<span class="fc" id="L1988">        return Math.min(1000.0, Math.max(-1000.0, (Math.round(100.0 * 100.0 * gval[0] / gval2[0]) / 100.0)));</span>
        }

    double nextDoubleClosedInterval(MersenneTwisterFast random) {
<span class="fc" id="L1992">        double tmp = random.nextDouble() * 2.0;</span>
<span class="fc bfc" id="L1993" title="All 2 branches covered.">        while (tmp &gt; 1.0)</span>
<span class="fc" id="L1994">            tmp = random.nextDouble() * 2.0;</span>
<span class="fc" id="L1995">        return tmp;</span>
        }
    }
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>